using System ;
using System.Collections.Generic ;
using System.ComponentModel ;
using System.Configuration ;
using System.Diagnostics ;
using System.Diagnostics.CodeAnalysis ;
using System.Linq ;
using System.Reflection ;
using System.Runtime.ExceptionServices ;
using System.Runtime.Serialization ;
using System.Threading.Tasks ;
using System.Windows ;
using System.Windows.Data ;
using System.Windows.Input ;
using System.Windows.Threading ;
using Autofac ;
using Autofac.Core ;
using DynamicData.Annotations ;
using ICSharpCode.NRefactory.CSharp ;
using NLog ;
using Vanara.Extensions.Reflection ;
using WpfApp.AppShared ;
using WpfApp.Common.Utils ;
using WpfApp.Config ;
using WpfApp.Core.Interfaces ;
using WpfApp.Core.Logging ;
using Exception = System.Exception ;
using IContainer = Autofac.IContainer ;

namespace WpfApp.Application
{
    /// <summary></summary>
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for ExitCode
    public enum ExitCode
    {
        /// <summary>The success</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Success
        // ReSharper disable once UnusedMember.Global
        Success = 0

       ,

        /// <summary>The general error</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for GeneralError
        GeneralError = 1

       ,

        /// <summary>The arguments error</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for ArgumentsError
        // ReSharper disable once UnusedMember.Global
        ArgumentsError = 2
    }

    /// <summary>
    ///     Interaction logic for App.xaml
    /// </summary>
    public partial class App : System.Windows.Application
    {
        private IContainer              _container ;
        private ContainerHelperSettings _containerHelperSettings ;

        /// <summary>Occurs when [debug message].</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for DebugMessage
        public event EventHandler < DebugEventArgs > DebugMessage ;

        /// <summary></summary>
        /// <param name="sender">The sender.</param>
        /// <param name="args">The <see cref="DebugEventArgs"/> instance containing the event data.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for OnDebugMessageRaised
        public delegate void OnDebugMessageRaised ( object sender , DebugEventArgs args ) ;

        /// <summary>Main application class</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for #ctor
        public App ( EventHandler < DebugEventArgs > debugEventHandler = null )
        {
            if ( debugEventHandler != null )
            {
                DebugMessage += debugEventHandler ;
            }

            DoLogMethod = ( message ) => OnDebugMessage ( new DebugEventArgs ( message ) ) ;
            AppLoggingConfigHelper.EnsureLoggingConfigured ( DoLogMethod ) ;

            ApplyConfiguration ( ) ;

            try
            {
                var s = new TaskCompletionSource < int > ( ) ;

                TCS = s ;
                var cd = AppDomain.CurrentDomain ;
                cd.AssemblyLoad += CurrentDomainOnAssemblyLoad ;
                //cd.TypeResolve += CdOnTypeResolve;
                cd.ProcessExit += ( sender , args ) => {
                    var argStr = args == null ? "Args is null" : args.ToString ( ) ;

                    DoLogMethod ( $"Exiting. args is {argStr}" ) ;
                } ;
                cd.UnhandledException += CdOnUnhandledException ;
                cd.ResourceResolve    += CdOnResourceResolve ;

                cd.FirstChanceException += CurrentDomainOnFirstChanceException ;
            }
            catch ( Exception ex )
            {
                DoLogMethod ( ex + "exception in constructor" ) ;
            }
        }

        private void ApplyConfiguration ( )
        {
            var config = ConfigurationManager.OpenExeConfiguration ( ConfigurationUserLevel.None ) ;
            DoLogMethod ( config.FilePath ) ;
            var type1 = typeof ( ContainerHelperSection ) ;
            //DoLogMethod( type1.AssemblyQualifiedName ) ;

            try
            {
                var sections = config.Sections ;
                string type ;
                foreach ( ConfigurationSection configSection in sections )
                {
                    try
                    {
                        // DoLogMethod (
                        // configSection.SectionInformation.Name
                        // + " : "
                        // + configSection.SectionInformation.Type
                        // ) ;
                        type = configSection.SectionInformation.Type ;
                        DoLogMethod ( $"Type is {type}" ) ;
                        var sectionType = Type.GetType ( type ) ;
                        if ( sectionType.Assembly == type1.Assembly )
                        {
                            DoLogMethod ( "Found section " + sectionType.Name ) ;
                            var at = sectionType.GetCustomAttribute < ConfigTargetAttribute > ( ) ;
                            var configTarget = Activator.CreateInstance ( at.TargetType ) ;
                            var infos = sectionType
                                       .GetMembers ( )
                                       .Select (
                                                info => Tuple.Create (
                                                                      info
                                                                    , info
                                                                         .GetCustomAttribute <
                                                                              ConfigurationPropertyAttribute
                                                                          > ( )
                                                                     )
                                               )
                                       .Where ( tuple => tuple.Item2 != null ) ;
                            foreach ( var info in infos )
                            {
                                if ( info.Item1.MemberType == MemberTypes.Property )
                                {
                                    foreach ( var memberInfo in infos )
                                    {
                                        var attr = at.TargetType.GetProperty ( info.Item1.Name ) ;
                                        try
                                        {
                                            var configVal =
                                                ( ( PropertyInfo ) memberInfo.Item1 ).GetValue (
                                                                                                configSection
                                                                                               ) ;
                                            attr.SetValue ( configTarget , configVal ) ;
                                        }
                                        catch ( Exception ex )
                                        {
                                            DoLogMethod (
                                                         $"Unable to set property {attr.Name}: {ex.Message}"
                                                        ) ;
                                        }
                                    }
                                }
                            }

                            ConfigSettings.Add ( configTarget ) ;
                        }
                    }
                    catch ( Exception ex1 )
                    {
                        Logger.Error ( ex1 , ex1.Message ) ;
                    }
                }
            }
            catch ( Exception ex )
            {
                DoLogMethod ( ex.Message ) ;
            }
        }

        /// <summary>Gets the configuration settings.</summary>
        /// <value>The configuration settings.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for configSettings
        public List < object > ConfigSettings { get ; } = new List < object > ( ) ;

        private ILogger Logger { get ; set ; } = LogManager.GetCurrentClassLogger ( ) ;

        private LogDelegates.LogMethod DoLogMethod { get ; }


        /// <summary>Gets the TCS.</summary>
        /// <value>The TCS.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for TCS
        public TaskCompletionSource < int > TCS { get ; }


        private ILifetimeScope AppContainer { get ; set ; }

        /// <summary>Gets or sets a value indicating whether [stage2 complete].</summary>
        /// <value>
        ///   <c>true</c> if [stage2 complete]; otherwise, <c>false</c>.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Stage2Complete
        // ReSharper disable once UnusedAutoPropertyAccessor.Global
        public bool Stage2Complete { get ; set ; }

        /// <summary>Gets or sets a value indicating whether this <see cref="App"/> is initialized.</summary>
        /// <value>
        ///   <c>true</c> if initialized; otherwise, <c>false</c>.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Initialized
        // ReSharper disable once UnusedAutoPropertyAccessor.Global
        public bool Initialized { get ; set ; }

        /// <summary>Gets or sets a value indicating whether [show main window].</summary>
        /// <value>
        ///   <c>true</c> if [show main window]; otherwise, <c>false</c>.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for ShowMainWindow
        // ReSharper disable once AutoPropertyCanBeMadeGetOnly.Global
        public bool ShowMainWindow { get ; set ; } = true ;

        /// <summary>Gets a value indicating whether [do tracing].</summary>
        /// <value>
        ///   <c>true</c> if [do tracing]; otherwise, <c>false</c>.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for DoTracing
        public bool DoTracing { get ; } = false ;

        // ReSharper disable once MemberCanBePrivate.Global
        /// <summary>Gets or sets the menu item list collection view.</summary>
        /// <value>The menu item list collection view.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for MenuItemListCollectionView
        public ListCollectionView MenuItemListCollectionView { get ; set ; }

        /// <summary>Gets or sets the dispatcher op.</summary>
        /// <value>The dispatcher op.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for DispatcherOp
        // ReSharper disable once UnusedAutoPropertyAccessor.Local
        private DispatcherOperation DispatcherOp { get ; set ; }

        /// <summary>
        ///     Whether the application should process command line arguments. used
        ///     for testing.
        /// </summary>
        /// <value>
        ///     <c>true</c> if [process arguments]; otherwise, <c>false</c>.
        /// </value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for ProcessArgs
        // ReSharper disable once AutoPropertyCanBeMadeGetOnly.Global
        public bool ProcessArgs { get ; set ; } = false ;

        // ReSharper disable once UnusedMember.Local
        private void DoLogMessage ( string message )
        {
            Logger?.Debug ( message ) ;
            Debug.WriteLine ( message ) ;
        }

        private Assembly CdOnResourceResolve ( object sender , ResolveEventArgs args )
        {
            DoLogMethod ( $"nameof(CdOnResourceResolve): {args.Name}" ) ;
            return null ;
        }

        private void CdOnUnhandledException ( object sender , UnhandledExceptionEventArgs e )
        {
            var message = e.ExceptionObject.GetPropertyValue < string > ( "Message" ) ;
            var err = new UnhandledException (
                                              "UnhandledException: " + message
                                            , e.ExceptionObject as Exception
                                             ) ;

            var str = $"{err.Message} Terminating={e.IsTerminating}" ;
            DoLogMethod ( str ) ;
        }


        // ReSharper disable once UnusedMember.Local
        // ReSharper disable once UnusedParameter.Local
        private Assembly CdOnTypeResolve ( object sender , ResolveEventArgs args )
        {
            DoLogMethod ( $"{args.Name}" ) ;
            DoLogMethod ( $"Requesting assembly is {args.RequestingAssembly.FullName}" ) ;
            return null ;
        }

        private void CurrentDomainOnAssemblyLoad ( object sender , AssemblyLoadEventArgs args )
        {
            Logger?.Trace ( args.LoadedAssembly ) ;
        }

        private void CurrentDomainOnFirstChanceException (
            object                        sender
          , FirstChanceExceptionEventArgs e
        )
        {
            try
            {
                var msg = $"{e.Exception.Message}" ;
                DoLogMethod ( msg ) ;
                Debug.WriteLine ( "Exception: " + e.Exception ) ;
                var inner = e.Exception.InnerException ;
                var seen = new HashSet < object > ( ) ;
                while ( inner != null
                        && ! seen.Contains ( inner ) )
                {
                    DoLogMethod ( inner.Message ) ;
                    seen.Add ( inner ) ;
                    inner = inner.InnerException ;
                }
            }
            catch ( Exception ex )
            {
                Debug.WriteLine ( "Exception: " + ex ) ;
            }
        }

        // ReSharper disable once UnusedMember.Local
        private string RegOutput ( IComponentRegistration registration )
        {
            var registrationActivator = registration.Activator ;
            if ( registrationActivator != null )
            {
                var registrationActivatorLimitType = registrationActivator.LimitType ;
                if ( registrationActivatorLimitType != null )
                {
                    return registrationActivatorLimitType.FullName ;
                }
            }

            return "" ;
        }

        // ReSharper disable once UnusedMember.Local
        private void OpenWindowExecuted ( object sender , ExecutedRoutedEventArgs e )
        {
            DoLogMethod ( $"{sender} {e.Parameter}" ) ;
        }

        [ SuppressMessage (
                              "Usage"
                            , "VSTHRD001:Avoid legacy thread switching APIs"
                            , Justification = "<Pending>"
                          ) ]
        private object DispatcherOperationCallback ( object arg )
        {
            DoLogMethod ( $"{nameof ( DispatcherOperationCallback )}" ) ;

            AppInitialize ( ) ;

            MainWindow mainWindow ;
            try
            {
                mainWindow = AppContainer.Resolve < MainWindow > ( ) ;
                DoLogMethod ( $"Received {mainWindow} " ) ;
            }
            catch ( Exception ex )
            {
                DoLogMethod ( "Cant resolve main Window: " + ex.Message ) ;
                // ReSharper disable once RedundantArgumentDefaultValue
                ErrorExit ( ExitCode.GeneralError ) ;
                return null ;
            }

            if ( ShowMainWindow )
            {
                try
                {
                    //mainWindow.WindowState = WindowState.Minimized ;
                    mainWindow.Show ( ) ;
                }
                catch ( Exception ex )
                {
                    DoLogMethod ( ex.Message ) ; //?.Error ( ex , ex.Message ) ;
                }
#if SHOWWINDOW
                var mainWindow = new MainWindow();
                mainWindow.Show();
#endif
            }


            Initialized = true ;

            return null ;
        }

        private void AppInitialize ( )
        {
            AppContainer =
                ContainerHelper.SetupContainer ( out var container , _containerHelperSettings ) ;
            _container = container ;

            SetupTracing ( ) ;


            var loggerTracker = AppContainer.Resolve < ILoggerTracker > ( ) ;
            var myLoggerName = typeof ( App ).FullName ;
            loggerTracker.LoggerRegistered += ( sender , args ) => {
                if ( args.Logger.Name == myLoggerName )
                {
                    args.Logger.Trace (
                                       "Received logger for application in LoggerREegistered handler."
                                      ) ;
                }
                else
                {
                    if ( Logger == null )
                    {
                        Debug.WriteLine ( "got a logger but i don't have one yet" ) ;
                    }
                }
            } ;

            Logger = AppContainer.Resolve < ILogger > (
                                                       new TypedParameter (
                                                                           typeof ( Type )
                                                                         , typeof ( App )
                                                                          )
                                                      ) ;


            if ( AppContainer.IsRegistered < IMenuItemList > ( ) )
            {
                var menuItemList = AppContainer.Resolve < IMenuItemList > ( ) ;
                MenuItemListCollectionView    = new ListCollectionView ( menuItemList ) ;
                Resources[ "MyMenuItemList" ] = menuItemList ;
            }


            var handler = new RoutedEventHandler ( MainWindowLoaded ) ;

            EventManager.RegisterClassHandler (
                                               typeof ( Window )
                                             , FrameworkElement.LoadedEvent
                                             , handler
                                              ) ;



            // var converter = new RegistrationConverter ( AppContainer , objectIdProvider ) ;
            // Resources[ "RegistrationConverter" ] = converter ;
            Stage2Complete = true ;
            TCS.SetResult ( 1 ) ;
        }

        private void SetupTracing ( )
        {
            PresentationTraceSources.Refresh ( ) ;
            if ( DoTracing )
            {
                var nLogTraceListener = new NLogTraceListener ( ) ;
                var routedEventSource = PresentationTraceSources.RoutedEventSource ;
                nLogTraceListener.DefaultLogLevel = LogLevel.Debug ;
                nLogTraceListener.ForceLogLevel   = LogLevel.Warn ;
                //nLogTraceListener.LogFactory      = AppContainer.Resolve < LogFactory > ( ) ;
                nLogTraceListener.AutoLoggerName = false ;
                //nLogTraceListener.
                routedEventSource.Switch.Level = SourceLevels.All ;
                var foo = AppContainer.Resolve < IEnumerable < TraceListener > > ( ) ;
                foreach ( var tl in foo )
                {
                    routedEventSource.Listeners.Add ( tl ) ;
                }

                //routedEventSource.Listeners.Add ( new AppTraceListener ( ) ) ;
                routedEventSource.Listeners.Add ( nLogTraceListener ) ;
            }
        }


        private void MainWindowLoaded ( object o , RoutedEventArgs args )
        {
            var w = o as MainWindow ;
            if ( w == null ) { }

            {
                Logger.Error ( $"Bad type for event sender {o.GetType ( )}" ) ;
            }

            var fe = o as FrameworkElement ;
            DoLogMethod ( $"{nameof ( MainWindowLoaded )}" ) ;
            Props.SetMenuItemListCollectionView ( fe , MenuItemListCollectionView ) ;
            DoLogMethod ( $"Setting LifetimeScope DependencyProperty to {AppContainer}" ) ;
            Props.SetAssemblyList (
                                   w
                                 , new AssemblyList ( AppDomain.CurrentDomain.GetAssemblies ( ) )
                                  ) ;
            Props.SetContainer ( fe , _container ) ;
            Props.SetLifetimeScope ( fe , AppContainer ) ;
        }

        private void AddEventListeners ( )
        {
            try
            {
                EventManager.RegisterClassHandler (
                                                   typeof ( Window )
                                                 , UIElement.KeyDownEvent
                                                 , new KeyEventHandler ( OnKeyDown )
                                                  ) ;
            }
            catch ( Exception ex )
            {
                DoLogMethod ( ex.Message ) ;
            }
        }

        private void OnKeyDown ( object sender , KeyEventArgs e )
        {
            if ( e.Key                         == Key.T
                 && e.KeyboardDevice.Modifiers == ( ModifierKeys.Control | ModifierKeys.Alt ) )
            {
                Process.Start (
                               new ProcessStartInfo (
                                                     @".\Demo.XamlDesigner.exe"
                                                   , @"..\WpfApp1\Windows\MainWindow.xaml"
                                                    ) { WorkingDirectory = @"..\..\..\tools" }
                              ) ;
            }
        }

        private void Application_DispatcherUnhandledException (
            object                                sender
          , DispatcherUnhandledExceptionEventArgs e
        )
        {
            var msg =
                $"{nameof ( Application_DispatcherUnhandledException )}: {e.Exception.Message}" ;
            DoLogMethod ( msg ) ;
            var inner = e.Exception.InnerException ;
            var seen = new HashSet < object > ( ) ;
            while ( inner != null
                    && ! seen.Contains ( inner ) )
            {
                DoLogMethod ( inner.Message ) ;
                seen.Add ( inner ) ;
                inner = inner.InnerException ;
            }
        }

        private void App_OnExit ( object sender , ExitEventArgs e )
        {
            DoLogMethod ( $"Application exiting.  Exit code is {e.ApplicationExitCode}" ) ;
        }

        /// <summary>
        ///     Raises the <see cref="E:System.Windows.Application.Startup" />
        ///     event.
        /// </summary>
        /// <param name="e">
        ///     A <see cref="T:System.Windows.StartupEventArgs" /> that
        ///     contains the event data.
        /// </param>
        protected override void OnStartup ( StartupEventArgs e )
        {
            DoOnStartup ( e.Args ) ;

            base.OnStartup ( e ) ;
        }

        /// <summary>Does the on startup.</summary>
        /// <param name="args">The arguments.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for DoOnStartup
        public void DoOnStartup ( string[] args )
        {
            AddEventListeners ( ) ;
            if ( ProcessArgs && args.Any ( ) )
            {
                var windowName = args[ 0 ] ;
                var xaml = "../Windows/" + windowName + ".xaml" ;
                var converter = TypeDescriptor.GetConverter ( typeof ( Uri ) ) ;
                if ( converter.CanConvertFrom ( typeof ( string ) ) )
                {
                    StartupUri = ( Uri ) converter.ConvertFrom ( xaml ) ;
                    Logger.Debug ( "Startup URI is {startupUri}" , StartupUri ) ;
                }
            }
            else
            {
                // ReSharper disable once PossibleNullReferenceException
                var dispatcherOperation = Dispatcher.BeginInvoke (
                                                                  DispatcherPriority.Send
                                                                , ( DispatcherOperationCallback )
                                                                  DispatcherOperationCallback
                                                                , null
                                                                 ) ;
                DispatcherOp = dispatcherOperation ;
            }
        }

        private void ErrorExit ( ExitCode exitCode = ExitCode.GeneralError )
        {
            var code = Convert.ChangeType ( exitCode , exitCode.GetTypeCode ( ) ) ;
            if ( code != null )
            {
                var intCode = ( int ) code ;

                DoLogMethod ( $"Exiting with code {intCode}, {exitCode}" ) ;
                if ( Current == null )
                {
                    DoLogMethod ( "No application reference" ) ;
                    Process.GetCurrentProcess ( ).Kill ( ) ;
                }
                else
                {
                    Current.Shutdown ( intCode ) ;
                }
            }
        }

        protected virtual void OnDebugMessage ( DebugEventArgs e )
        {
            Logger?.Debug ( e.Message ) ;
            DebugMessage?.Invoke ( this , e ) ;
        }
    }


    /// <summary></summary>
    /// <seealso cref="System.Exception" />
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for UnhandledException
    [ Serializable ]
    public class UnhandledException : Exception
    {
        /// <summary>
        ///     Initializes a new instance of the <see cref="T:System.Exception" />
        ///     class.
        /// </summary>
        // ReSharper disable once UnusedMember.Global
        public UnhandledException ( ) { }

        /// <summary>
        ///     Initializes a new instance of the <see cref="T:System.Exception" />
        ///     class with a specified error message.
        /// </summary>
        /// <param name="message">The message that describes the error.</param>
        public UnhandledException ( string message ) : base ( message ) { }

        /// <summary>
        ///     Initializes a new instance of the <see cref="T:System.Exception" />
        ///     class with a specified error message and a reference to the inner
        ///     exception
        ///     that is the cause of this exception.
        /// </summary>
        /// <param name="message">
        ///     The error message that explains the reason for the
        ///     exception.
        /// </param>
        /// <param name="innerException">
        ///     The exception that is the cause of the current
        ///     exception, or a null reference (<see langword="Nothing" /> in Visual
        ///     Basic)
        ///     if no inner exception is specified.
        /// </param>
        public UnhandledException ( string message , Exception innerException ) : base (
                                                                                        message
                                                                                      , innerException
                                                                                       )
        {
        }

        /// <summary>
        ///     Initializes a new instance of the <see cref="T:System.Exception" />
        ///     class with serialized data.
        /// </summary>
        /// <param name="info">
        ///     The
        ///     <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that
        ///     holds
        ///     the serialized object data about the exception being thrown.
        /// </param>
        /// <param name="context">
        ///     The
        ///     <see cref="T:System.Runtime.Serialization.StreamingContext" /> that
        ///     contains contextual information about the source or destination.
        /// </param>
        /// <exception cref="T:System.ArgumentNullException">
        ///     <paramref name="info" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Runtime.Serialization.SerializationException">
        ///     The
        ///     class name is <see langword="null" /> or
        ///     <see cref="P:System.Exception.HResult" /> is zero (0).
        /// </exception>
        protected UnhandledException (
            [ NotNull ] SerializationInfo info
          , StreamingContext              context
        ) : base ( info , context )
        {
        }
    }
}