// #undef TRACE_EVENTS

using System ;
using System.Windows ;
using System.Windows.Controls ;
using System.Windows.Data ;
using Autofac ;
using JetBrains.Annotations ;
using NLog ;
using WpfApp.Core ;

// ReSharper disable UnusedMember.Global

namespace WpfApp
{
    /// <summary>Static class holding attached properties and events..</summary>
    public static class Props
    {
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger ( ) ;
        // ReSharper disable once MemberCanBePrivate.Global
        /// <summary>The logger registered event</summary>
        public static readonly RoutedEvent LoggerRegisteredEvent =
            EventManager.RegisterRoutedEvent (
                                              "LoggerRegistered"
                                              , RoutingStrategy.Direct
                                              , typeof ( RoutedEventHandler )
                                              , typeof ( Props )
                                              ) ;

        /// <summary>Event fired when attached property MenuItemListCollectionView is updated.</summary>
        ///  <seealso cref="MenuItemListCollectionViewProperty"/>
        public static readonly RoutedEvent MenuItemListCollectionViewChangedEvent =
            EventManager.RegisterRoutedEvent (
                                              "MenuItemListCollectionViewChanged"
                                            , RoutingStrategy.Direct
                                            , typeof ( RoutedPropertyChangedEventHandler <
                                                  CollectionView > )
                                            , typeof ( Props )
                                             ) ;

        /// <summary>
        /// Attached property for Menu Item List CollectionView.
        /// </summary>
        /// <seealso cref="MenuItemListCollectionViewChangedEvent"/>
         public static readonly DependencyProperty MenuItemListCollectionViewProperty =
            DependencyProperty.RegisterAttached (
                                                 "MenuItemListCollectionView"
                                               , typeof ( CollectionView )
                                               , typeof ( Props )
                                               , new FrameworkPropertyMetadata (
                                                                                null
                                                                              , FrameworkPropertyMetadataOptions
                                                                                   .Inherits
                                                                              , OnMenuItemListCollectionViewChanged
                                                                              , CoerceMenuItemListCollectionView
                                                                              , false
                                                                              , UpdateSourceTrigger
                                                                                   .PropertyChanged
                                                                               )
                                                ) ;


        // ReSharper disable once MemberCanBePrivate.Global
        /// <summary>The lifetime scope changed event</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for LifetimeScopeChangedEvent
        public static readonly RoutedEvent LifetimeScopeChangedEvent =
            EventManager.RegisterRoutedEvent (
                                              "LifetimeScopeChanged"
                                            , RoutingStrategy.Bubble
                                            , typeof ( RoutedPropertyChangedEventHandler <
                                                  ILifetimeScope > )
                                            , typeof ( Props )
                                             ) ;

        /// <summary>The lifetime scope property</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for LifetimeScopeProperty
        public static readonly DependencyProperty LifetimeScopeProperty =
            DependencyProperty.RegisterAttached (
                                                 "LifetimeScope"
                                               , typeof ( ILifetimeScope )
                                               , typeof ( Props )
                                               , new FrameworkPropertyMetadata (
                                                                                null
                                                                              , FrameworkPropertyMetadataOptions
                                                                                   .Inherits
                                                                              , OnLifetimeScopeChanged
                                                                              , CoerceLifetimeScopeValue
                                                                              , false
                                                                              , UpdateSourceTrigger
                                                                                   .PropertyChanged
                                                                               )
                                                ) ;

        /// <summary>The rendered type changed event</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for RenderedTypeChangedEvent
        public static readonly RoutedEvent RenderedTypeChangedEvent =
            EventManager.RegisterRoutedEvent (
                                              "RenderedTypeChanged"
                                            , RoutingStrategy.Direct
                                            , typeof ( RoutedPropertyChangedEventHandler < Type > )
                                            , typeof ( Props )
                                             ) ;

        /// <summary>The rendered type property</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for RenderedTypeProperty
        public static readonly DependencyProperty RenderedTypeProperty =
            DependencyProperty.RegisterAttached (
                                                 "RenderedType"
                                               , typeof ( Type )
                                               , typeof ( Props )
                                               , new FrameworkPropertyMetadata (
                                                                                null
                                                                              , FrameworkPropertyMetadataOptions
                                                                                   .Inherits
                                                                              , OnRenderedTypeChanged
                                                                              , CoerceRenderedTypeValue
                                                                              , false
                                                                              , UpdateSourceTrigger
                                                                                   .PropertyChanged
                                                                               )
                                                ) ;


        /// <summary>The assembly list changed event</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for AssemblyListChangedEvent
        public static readonly RoutedEvent AssemblyListChangedEvent =
            EventManager.RegisterRoutedEvent (
                                              "AssemblyListChanged"
                                            , RoutingStrategy.Direct
                                            , typeof ( RoutedPropertyChangedEventHandler <
                                                  AssemblyList > )
                                            , typeof ( Props )
                                             ) ;

        /// <summary>The assembly list property</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for AssemblyListProperty
        public static readonly DependencyProperty AssemblyListProperty =
            DependencyProperty.RegisterAttached (
                                                 "AssemblyList"
                                               , typeof ( AssemblyList )
                                               , typeof ( Props )
                                               , new FrameworkPropertyMetadata (
                                                                                null
                                                                              , FrameworkPropertyMetadataOptions
                                                                                   .None
                                                                              , OnAssemblyListChanged
                                                                              , CoerceAssemblyList
                                                                              , false
                                                                              , UpdateSourceTrigger
                                                                                   .PropertyChanged
                                                                               )
                                                ) ;

        /// <summary>The container changed event</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for ContainerChangedEvent
        public static readonly RoutedEvent ContainerChangedEvent =
            EventManager.RegisterRoutedEvent (
                                              "ContainerChanged"
                                            , RoutingStrategy.Bubble
                                            , typeof ( RoutedPropertyChangedEventHandler <
                                                  IContainer > )
                                            , typeof ( Props )
                                             ) ;

        /// <summary>The container property</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for ContainerProperty
        public static readonly DependencyProperty ContainerProperty =
            DependencyProperty.RegisterAttached (
                                                 "Container"
                                               , typeof ( IContainer )
                                               , typeof ( Props )
                                               , new FrameworkPropertyMetadata (
                                                                                null
                                                                              , FrameworkPropertyMetadataOptions
                                                                                   .None
                                                                              , OnContainerChanged
                                                                              , CoerceContainerValue
                                                                              , false
                                                                              , UpdateSourceTrigger
                                                                                   .PropertyChanged
                                                                               )
                                                ) ;


        private static object CoerceMenuItemListCollectionView (
            DependencyObject d
          , object           baseValue
        )
        {
            return baseValue ;
        }

        /// <summary>Called when [menu item list collection view changed].</summary>
        /// <param name="d">The d.</param>
        /// <param name="e">
        ///     The <see cref="DependencyPropertyChangedEventArgs" />
        ///     instance containing the event data.
        /// </param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for OnMenuItemListCollectionViewChanged
        private static void OnMenuItemListCollectionViewChanged (
            DependencyObject                   d
          , DependencyPropertyChangedEventArgs e
        )
        {
            var evt = MenuItemListCollectionViewChangedEvent ;
            var ev = new RoutedPropertyChangedEventArgs < CollectionView > (
                                                                            ( CollectionView ) e
                                                                               .OldValue
                                                                          , ( CollectionView ) e
                                                                               .NewValue
                                                                          , evt
                                                                           ) ;
            switch ( d )
            {
                case UIElement uie :
#if TRACE_MENUEVENTS
                Logger.Trace ( $"Raising event on UIElement {evt.Name}" ) ;
#endif
                    uie.RaiseEvent ( ev ) ;
                    break ;
                case ContentElement ce :
#if TRACE_MENU_EVENTS
                Logger.Trace ( $"Raising event on ContentElement {evt.Name}" ) ;
#endif
                    ce.RaiseEvent ( ev ) ;
                    break ;
                default :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on incompatible type {evt.Name}" ) ;
#endif
                    break ;
            }
        }

        /// <summary>Adds the on menu item list collection view changed handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for AddOnMenuItemListCollectionViewChangedHandler
        public static void AddOnMenuItemListCollectionViewChangedHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :
                    uie.AddHandler ( MenuItemListCollectionViewChangedEvent , handler ) ;
                    break ;
                case ContentElement ce :
                    ce.AddHandler ( MenuItemListCollectionViewChangedEvent , handler ) ;
                    break ;
            }
        }

        /// <summary>Removes the on menu item list collection view changed handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for RemoveOnMenuItemListCollectionViewChangedHandler
        public static void RemoveOnMenuItemListCollectionViewChangedHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :
                    uie.AddHandler ( MenuItemListCollectionViewChangedEvent , handler ) ;
                    break ;
                case ContentElement ce :
                    ce.AddHandler ( MenuItemListCollectionViewChangedEvent , handler ) ;
                    break ;
            }
        }

        /// <summary>Gets the menu item list collection view.</summary>
        /// <param name="target">The target.</param>
        /// <returns></returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for GetMenuItemListCollectionView
        [ AttachedPropertyBrowsableForType ( typeof ( Window ) ) ]
        [ AttachedPropertyBrowsableForType ( typeof ( FrameworkElement ) ) ]
        public static CollectionView GetMenuItemListCollectionView ( [ NotNull ] DependencyObject target )
        {
            if ( target == null )
            {
                throw new ArgumentNullException ( nameof ( target ) ) ;
            }

            Logger.Trace ( $"{nameof ( GetMenuItemListCollectionView )} {target}" ) ;
            return ( CollectionView ) target.GetValue ( MenuItemListCollectionViewProperty ) ;
        }

        /// <summary>Sets the menu item list collection view.</summary>
        /// <param name="target">The target.</param>
        /// <param name="value">The value.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for SetMenuItemListCollectionView
        public static void SetMenuItemListCollectionView (
            DependencyObject target
          , CollectionView   value
        )
        {
#if TRACE_EVENTS
            Logger.Trace ( $"{nameof ( SetMenuItemListCollectionView )} {target}, {value}" ) ;
#endif

            target.SetValue ( MenuItemListCollectionViewProperty , value ) ;
        }


        /// <summary>Adds the logger registered handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for AddLoggerRegisteredHandler
        public static void AddLoggerRegisteredHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :
                    uie.AddHandler ( LoggerRegisteredEvent , handler ) ;
                    break ;
                case ContentElement ce :
                    ce.AddHandler ( LoggerRegisteredEvent , handler ) ;
                    break ;
            }
        }

        // ReSharper disable once UnusedMember.Global
        /// <summary>Removes the logger registered handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for RemoveLoggerRegisteredHandler
        public static void RemoveLoggerRegisteredHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :
                    uie.RemoveHandler ( LoggerRegisteredEvent , handler ) ;
                    break ;
                case ContentElement ce :
                    ce.RemoveHandler ( LoggerRegisteredEvent , handler ) ;
                    break ;
            }
        }

        private static object CoerceLifetimeScopeValue ( DependencyObject d , object baseValue )
        {
            return baseValue ;
        }


        private static void OnLifetimeScopeChanged (
            DependencyObject                   d
          , DependencyPropertyChangedEventArgs e
        )
        {
            var evt = LifetimeScopeChangedEvent ;
            var ev = new RoutedPropertyChangedEventArgs < ILifetimeScope > (
                                                                            ( ILifetimeScope ) e
                                                                               .OldValue
                                                                          , ( ILifetimeScope ) e
                                                                               .NewValue
                                                                          , evt
                                                                           ) ;
            switch ( d )
            {
                case UIElement uie :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on UIElement {d.GetType ()}  {evt.Name}" ) ;
#endif
                    uie.RaiseEvent ( ev ) ;
                    break ;
                case ContentElement ce :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on ContentElement {evt.Name}" ) ;
#endif
                    ce.RaiseEvent ( ev ) ;
                    break ;
                default :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on incompatible type {evt.Name}" ) ;
#endif
                    break ;
            }
        }

        // ReSharper disable once UnusedMember.Global
        /// <summary>Adds the lifetime scope changed event handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for AddLifetimeScopeChangedEventHandler
        public static void AddLifetimeScopeChangedEventHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :
                    uie.AddHandler ( LifetimeScopeChangedEvent , handler ) ;
                    break ;
                case ContentElement ce :
                    ce.AddHandler ( LifetimeScopeChangedEvent , handler ) ;
                    break ;
            }
        }

        /// <summary>Removes the lifetime scope changed event handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for RemoveLifetimeScopeChangedEventHandler
        public static void RemoveLifetimeScopeChangedEventHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :
                    uie.AddHandler ( LifetimeScopeChangedEvent , handler ) ;
                    break ;
                case ContentElement ce :
                    ce.AddHandler ( LifetimeScopeChangedEvent , handler ) ;
                    break ;
            }
        }


        /// <summary>Gets the lifetime scope.</summary>
        /// <param name="target">The target.</param>
        /// <returns></returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for GetLifetimeScope
        [ AttachedPropertyBrowsableForType ( typeof ( Window ) ) ]
        [ AttachedPropertyBrowsableForType ( typeof ( UserControl ) ) ]
        [ AttachedPropertyBrowsableForType ( typeof ( FrameworkElement ) ) ]
        public static ILifetimeScope GetLifetimeScope ( [ NotNull ] DependencyObject target )
        {
            if ( target == null )
            {
                throw new ArgumentNullException ( nameof ( target ) ) ;
            }

            return ( ILifetimeScope ) target.GetValue ( LifetimeScopeProperty ) ;
        }

        /// <summary>Sets the lifetime scope.</summary>
        /// <param name="target">The target.</param>
        /// <param name="value">The value.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for SetLifetimeScope
        public static void SetLifetimeScope ( DependencyObject target , ILifetimeScope value )
        {
#if TRACE_EVENTS
            Logger.Trace ( $"{nameof ( SetMenuItemListCollectionView )} {target}, {value}" ) ;
#endif

            target.SetValue ( LifetimeScopeProperty , value ) ;
        }

        private static object CoerceRenderedTypeValue ( DependencyObject d , object baseValue )
        {
            return baseValue ;
        }


        private static void OnRenderedTypeChanged (
            DependencyObject                   d
          , DependencyPropertyChangedEventArgs e
        )
        {
            var evt = RenderedTypeChangedEvent ;
            var ev = new RoutedPropertyChangedEventArgs < Type > (
                                                                  ( Type ) e.OldValue
                                                                , ( Type ) e.NewValue
                                                                , evt
                                                                 ) ;
            switch ( d )
            {
                case UIElement uie :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on UIElement {evt.Name}" ) ;
#endif
                    uie.RaiseEvent ( ev ) ;
                    break ;
                case ContentElement ce :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on ContentElement {evt.Name}" ) ;
#endif
                    ce.RaiseEvent ( ev ) ;
                    break ;
                default :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on incompatible type {evt.Name}" ) ;
#endif
                    break ;
            }
        }

        // ReSharper disable once UnusedMember.Global
        /// <summary>Adds the rendered type changed event handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for AddRenderedTypeChangedEventHandler
        public static void AddRenderedTypeChangedEventHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :     uie.AddHandler ( RenderedTypeChangedEvent , handler ) ;
                    break ;
                case ContentElement ce : ce.AddHandler ( RenderedTypeChangedEvent , handler ) ;
                    break ;
            }
        }

        /// <summary>Removes the rendered type changed event handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for RemoveRenderedTypeChangedEventHandler
        public static void RemoveRenderedTypeChangedEventHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :     uie.AddHandler ( RenderedTypeChangedEvent , handler ) ;
                    break ;
                case ContentElement ce : ce.AddHandler ( RenderedTypeChangedEvent , handler ) ;
                    break ;
            }
        }

        /// <summary>Gets the type of the rendered.</summary>
        /// <param name="target">The target.</param>
        /// <returns></returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for GetRenderedType
        [ AttachedPropertyBrowsableForType ( typeof ( Window ) ) ]
        public static Type GetRenderedType ( [ NotNull ] DependencyObject target )
        {
            if ( target == null )
            {
                throw new ArgumentNullException ( nameof ( target ) ) ;
            }

            return ( Type ) target.GetValue ( RenderedTypeProperty ) ;
        }

        /// <summary>Sets the type of the rendered.</summary>
        /// <param name="target">The target.</param>
        /// <param name="value">The value.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for SetRenderedType
        public static void SetRenderedType ( [ NotNull ] DependencyObject target , Type value )
        {
            if ( target == null )
            {
                throw new ArgumentNullException ( nameof ( target ) ) ;
            }
#if TRACE_EVENTS
            Logger.Trace ( $"{nameof ( SetMenuItemListCollectionView )} {target}, {value}" ) ;
#endif

            target.SetValue ( RenderedTypeProperty , value ) ;
        }


        private static object CoerceAssemblyList ( [ NotNull ] DependencyObject d , object baseValue )
        {
            if ( d == null )
            {
                throw new ArgumentNullException ( nameof ( d ) ) ;
            }

            return baseValue ;
        }

        private static void OnAssemblyListChanged (
            [ NotNull ] DependencyObject                   d
          , DependencyPropertyChangedEventArgs e
        )
        {
            if ( d == null )
            {
                throw new ArgumentNullException ( nameof ( d ) ) ;
            }

            var evt = AssemblyListChangedEvent ;
            var ev = new RoutedPropertyChangedEventArgs < AssemblyList > (
                                                                          ( AssemblyList ) e
                                                                             .OldValue
                                                                        , ( AssemblyList ) e
                                                                             .NewValue
                                                                        , evt
                                                                         ) ;
            switch ( d )
            {
                case UIElement uie :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on UIElement {evt.Name}" ) ;
#endif
                    uie.RaiseEvent ( ev ) ;
                    break ;
                case ContentElement ce :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on ContentElement {evt.Name}" ) ;
#endif
                    ce.RaiseEvent ( ev ) ;
                    break ;
                default :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on incompatible type {evt.Name}" ) ;
#endif
                    break ;
            }
        }

        /// <summary>Adds the on assembly list changed handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for AddOnAssemblyListChangedHandler
        public static void AddOnAssemblyListChangedHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :     uie.AddHandler ( AssemblyListChangedEvent , handler ) ;
                    break ;
                case ContentElement ce : ce.AddHandler ( AssemblyListChangedEvent , handler ) ;
                    break ;
            }
        }

        /// <summary>Removes the on assembly list changed handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for RemoveOnAssemblyListChangedHandler
        public static void RemoveOnAssemblyListChangedHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :     uie.AddHandler ( AssemblyListChangedEvent , handler ) ;
                    break ;
                case ContentElement ce : ce.AddHandler ( AssemblyListChangedEvent , handler ) ;
                    break ;
            }
        }

        // [AttachedPropertyBrowsableForType(typeof(Window))]
        /// <summary>
        ///     Helper for getting <see cref="AssemblyListProperty" />
        ///     from <paramref name="target" />.
        /// </summary>
        /// <param name="target">
        ///     <see cref="System.Windows.DependencyObject" /> to read
        ///     <see cref="AssemblyListProperty" /> from.
        /// </param>
        /// <returns>AssemblyList property value.</returns>
        [ AttachedPropertyBrowsableForType ( typeof ( Window ) ) ]
//		[ AttachedPropertyBrowsableForType ( typeof ( AssemblyBrowser ) ) ]
        // [AttachedProperty    BrowsableForType(typeof(ItemsControl))]
        public static AssemblyList GetAssemblyList ( [ NotNull ] DependencyObject target )
        {
            if ( target == null )
            {
                throw new ArgumentNullException ( nameof ( target ) ) ;
            }

            Logger.Trace ( $"{nameof ( GetAssemblyList )} {target}" ) ;
            return ( AssemblyList ) target.GetValue ( AssemblyListProperty ) ;
        }

        /// <summary>Sets the assembly list.</summary>
        /// <param name="target">The target.</param>
        /// <param name="value">The value.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for SetAssemblyList
        public static void SetAssemblyList ( DependencyObject target , AssemblyList value )
        {
#if TRACE_EVENTS
            Logger.Trace ( $"{nameof ( SetAssemblyList )} {target}, {value}" ) ;
#endif

            target.SetValue ( AssemblyListProperty , value ) ;
        }

        private static object CoerceContainerValue ( DependencyObject d , object baseValue )
        {
            return baseValue ;
        }


        private static void OnContainerChanged (
            DependencyObject                   d
          , DependencyPropertyChangedEventArgs e
        )
        {
            var evt = ContainerChangedEvent ;
            var ev = new RoutedPropertyChangedEventArgs < IContainer > (
                                                                        ( IContainer ) e.OldValue
                                                                      , ( IContainer ) e.NewValue
                                                                      , evt
                                                                       ) ;
            switch ( d )
            {
                case UIElement uie :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on UIElement {d.GetType ()}  {evt.Name}" ) ;
#endif
                    uie.RaiseEvent ( ev ) ;
                    break ;
                case ContentElement ce :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on ContentElement {evt.Name}" ) ;
#endif
                    ce.RaiseEvent ( ev ) ;
                    break ;
                default :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on incompatible type {evt.Name}" ) ;
#endif
                    break ;
            }
        }

        /// <summary>Adds the container changed event handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for AddContainerChangedEventHandler
        public static void AddContainerChangedEventHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :     uie.AddHandler ( ContainerChangedEvent , handler ) ;
                    break ;
                case ContentElement ce : ce.AddHandler ( ContainerChangedEvent , handler ) ;
                    break ;
            }
        }

        /// <summary>Removes the container changed event handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for RemoveContainerChangedEventHandler
        public static void RemoveContainerChangedEventHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :     uie.AddHandler ( ContainerChangedEvent , handler ) ;
                    break ;
                case ContentElement ce : ce.AddHandler ( ContainerChangedEvent , handler ) ;
                    break ;
            }
        }


        /// <summary>Gets the container.</summary>
        /// <param name="target">The target.</param>
        /// <returns></returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for GetContainer
        [ AttachedPropertyBrowsableForType ( typeof ( Window ) ) ]
        public static IContainer GetContainer ( [ NotNull ] DependencyObject target )
        {
            if ( target == null )
            {
                throw new ArgumentNullException ( nameof ( target ) ) ;
            }

            return ( IContainer ) target.GetValue ( ContainerProperty ) ;
        }

        /// <summary>Sets the container.</summary>
        /// <param name="target">The target.</param>
        /// <param name="value">The value.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for SetContainer
        public static void SetContainer ( DependencyObject target , IContainer value )
        {
#if TRACE_EVENTS
            Logger.Trace ( $"{nameof ( SetMenuItemListCollectionView )} {target}, {value}" ) ;
#endif

            target.SetValue ( ContainerProperty , value ) ;
        }

        /// <summary>The resolve service list changed event</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for ResolveServiceListChangedEvent
        public static readonly RoutedEvent ResolveServiceListChangedEvent =
            EventManager.RegisterRoutedEvent(
                                              "ResolveServiceListChanged"
                                            , RoutingStrategy.Direct
                                            , typeof(RoutedPropertyChangedEventHandler<
                                                  ResolveServiceList>)
                                            , typeof(Props)
                                             );

        /// <summary>The resolve service list property</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for ResolveServiceListProperty
        public static readonly DependencyProperty ResolveServiceListProperty =
            DependencyProperty.RegisterAttached(
                                                 "ResolveServiceList"
                                               , typeof(ResolveServiceList)
                                               , typeof(Props)
                                               , new FrameworkPropertyMetadata(
                                                                                null
                                                                              , FrameworkPropertyMetadataOptions
                                                                                   .None
                                                                              , OnResolveServiceListChanged
                                                                              , CoerceResolveServiceList
                                                                              , false
                                                                              , UpdateSourceTrigger
                                                                                   .PropertyChanged
                                                                               )
                                                );

        private static object CoerceResolveServiceList ( DependencyObject d , object baseValue )
        {
            return baseValue ;
        }

        private static void OnResolveServiceListChanged (
            DependencyObject                   d
          , DependencyPropertyChangedEventArgs e
        )
        {
            var evt = ResolveServiceListChangedEvent ;
            var ev = new RoutedPropertyChangedEventArgs < ResolveServiceList > (
                                                                                ( ResolveServiceList
                                                                                ) e.OldValue
                                                                              , ( ResolveServiceList
                                                                                ) e.NewValue
                                                                              , evt
                                                                               ) ;
            switch ( d )
            {
                case UIElement uie :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on UIElement {evt.Name}" ) ;
#endif
                    uie.RaiseEvent ( ev ) ;
                    break ;
                case ContentElement ce :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on ContentElement {evt.Name}" ) ;
#endif
                    ce.RaiseEvent ( ev ) ;
                    break ;
                default :
#if TRACE_EVENTS
                Logger.Trace ( $"Raising event on incompatible type {evt.Name}" ) ;
#endif
                    break ;
            }
        }

        /// <summary>Adds the on resolve service list changed handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for AddOnResolveServiceListChangedHandler
        public static void AddOnResolveServiceListChangedHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :     uie.AddHandler ( ResolveServiceListChangedEvent , handler ) ;
                    break ;
                case ContentElement ce : ce.AddHandler ( ResolveServiceListChangedEvent , handler ) ;
                    break ;
            }
        }

        /// <summary>Removes the on resolve service list changed handler.</summary>
        /// <param name="d">The d.</param>
        /// <param name="handler">The handler.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for RemoveOnResolveServiceListChangedHandler
        public static void RemoveOnResolveServiceListChangedHandler (
            DependencyObject   d
          , RoutedEventHandler handler
        )
        {
            switch ( d )
            {
                case UIElement uie :     uie.AddHandler ( ResolveServiceListChangedEvent , handler ) ;
                    break ;
                case ContentElement ce : ce.AddHandler ( ResolveServiceListChangedEvent , handler ) ;
                    break ;
            }
        }

        /// <summary>
        ///     Helper for getting <see cref="ResolveServiceListProperty" />
        ///     from <paramref name="target" />.
        /// </summary>
        /// <param name="target">
        ///     <see cref="System.Windows.DependencyObject" /> to read
        ///     <see cref="ResolveServiceListProperty" /> from.
        /// </param>
        /// <returns>ResolveServiceList property value.</returns>
        [ AttachedPropertyBrowsableForType ( typeof ( Window ) ) ]
        [ AttachedPropertyBrowsableForType ( typeof ( FrameworkElement ) ) ]
        [ AttachedPropertyBrowsableForType ( typeof ( UserControl ) ) ]
        //		[ AttachedPropertyBrowsableForType ( typeof ( AssemblyBrowser ) ) ]
        // [AttachedProperty    BrowsableForType(typeof(ItemsControl))]
        public static ResolveServiceList GetResolveServiceList ( DependencyObject target )
        {
            Logger.Trace ( $"{nameof ( GetResolveServiceList )} {target}" ) ;
            return ( ResolveServiceList ) target.GetValue ( ResolveServiceListProperty ) ;
        }

        /// <summary>Sets the resolve service list.</summary>
        /// <param name="target">The target.</param>
        /// <param name="value">The value.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for SetResolveServiceList
        public static void SetResolveServiceList (
            DependencyObject   target
          , ResolveServiceList value
        )
        {
#if TRACE_EVENTS
            Logger.Trace ( $"{nameof ( SetResolveServiceList )} {target}, {value}" ) ;
#endif

            target.SetValue ( ResolveServiceListProperty , value ) ;
        }


    }
}
