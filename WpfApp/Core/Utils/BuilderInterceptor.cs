using System ;
using System.CodeDom ;
using System.Collections.Generic ;
using System.Linq ;
using System.Reflection ;
using System.Runtime.CompilerServices ;
using Autofac.Builder ;
using Autofac.Core ;
using Castle.DynamicProxy ;
using Microsoft.CSharp ;
using NJection.LambdaConverter.Fluent ;
using NLog ;
using WpfApp.Core.Model ;

namespace WpfApp.Core.Utils
{

    /// <summary></summary>
    /// <seealso cref="Castle.DynamicProxy.IInterceptor" />
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for BaseInterceptor
    public abstract class BaseInterceptor : IInterceptor
    {
        /// <summary>Gets the generator.</summary>
        /// <value>The generator.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Generator
        // ReSharper disable once UnusedAutoPropertyAccessor.Global
        protected ProxyGenerator Generator { get ; }

        private static readonly Logger Logger = LogManager.GetCurrentClassLogger ( ) ;

        /// <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        protected BaseInterceptor (ProxyGenerator generator) { Generator = generator ; }

        /// <summary>Dumps the delegate.</summary>
        /// <param name="d">The d.</param>
        /// <param name="prefix">Prefix to prepend to log messages</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for DumpDelegate
        protected void DumpDelegate ( Delegate d , string prefix = "" )
        {
            try
            {
                var expression = Lambda.TransformMethodTo < Delegate > ( )
                                       .From ( ( ) => d )
                                       .ToLambda ( ) ;
                Logger.Debug ( $"{expression}" ) ;
            }
            catch ( Exception )
            {
                // ignored
            }

            var typeDesc = NameForType ( d.Target.GetType ( ) ) ;
            var methodInfo = d.Method ;
            var g = methodInfo.IsGenericMethod ;
            var s = methodInfo.IsSpecialName ;
            foreach ( var att in methodInfo.CustomAttributes )
            {
                Logger.Info ( $"{prefix}{att}" ) ;
            }

            if ( methodInfo.CustomAttributes.Any (
                                                  data => data.AttributeType
                                                          == typeof ( CompilerGeneratedAttribute )
                                                 ) )
            {
                Logger.Info ( "compiler generated" ) ;
            }

            Logger.Info ( $"{prefix}Delegate: {s} {g} {typeDesc} {methodInfo.Name}" ) ;
        }

        /// <summary>Names for type.</summary>
        /// <param name="myType">My type.</param>
        /// <returns></returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for NameForType
        protected string NameForType ( Type myType )
        {
            var provider = new CSharpCodeProvider ( ) ;
            if ( myType.IsGenericType )
            {
                var type = myType.GetGenericTypeDefinition ( ) ;
                myType = type ;
            }

            var codeTypeReference = new CodeTypeReference ( myType ) ;
            var q = codeTypeReference ;
            //myType.GetGenericTypeParameters()
            return provider.GetTypeOutput ( q ) ;
            // return myType.IsGenericType ? myType.GetGenericTypeDefinition ( ).Name : myType.Name ;
        }

        /// <summary>Intercepts the specified invocation.</summary>
        /// <param name="invocation">The invocation.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Intercept
        public abstract void Intercept ( IInvocation invocation ) ;
    }


    /// <summary>Interceptor for Autofac container builder. Used for diagnostics.</summary>
    /// <seealso cref="Castle.DynamicProxy.IInterceptor" />
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for BuilderInterceptor
    public class BuilderInterceptor : BaseInterceptor
    {
        /// <summary>The logger</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Logger
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger ( ) ;

        /// <summary>Gets the invocations.</summary>
        /// <value>The invocations.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Invocations
        public List < MethodInvocation > Invocations { get ; } = new List < MethodInvocation > ( ) ;

        /// <summary>Intercepts the specified invocation.</summary>
        /// <param name="invocation">The invocation.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Intercept
        public override void Intercept ( IInvocation invocation )
        {
            if ( invocation != null )
            {
                var i = new MethodInvocation ( invocation.Method , invocation.Arguments ) ;
                Invocations.Add ( i ) ;
                invocation.Proceed ( ) ;
                i.OriginalReturnValue = invocation.ReturnValue ;
                try
                {
                    
                    if ( i.OriginalReturnValue is DeferredCallback cb )
                    {
                        object origArg = null ;
                        if ( invocation.Method.Name == "RegisterCallback" )
                        {
                            origArg = invocation.Arguments[ 0 ] ;
                        }


                        Logger.Info ( $"{invocation.Method.Name} returning deferred callback" ) ;
                        var cbAction = cb.Callback ;
                        Action < IComponentRegistry > newCbAction = ( IComponentRegistry reg ) => {
                            var p2 = Generator
                               .CreateInterfaceProxyWithTarget < IComponentRegistry > (
                                                                                       reg
                                                                                     , new
                                                                                           RegistryInterceptor (Generator )
                                                                                      ) ;
                            Logger.Info ( "in callback" ) ;
                            if ( origArg != null )
                            {
                                if ( origArg is Delegate d )
                                {
                                    DumpDelegate(d);
                                    // var method = d.Method ;
                                    // var target = d.Target ;
                                    // Logger.Info (
                                    //              $"{target} ({target.GetType ( )}) {method.Name}"
                                    //             ) ;
                                }
                            }


                            Logger.Info ( $"{origArg}" ) ;
                            cbAction ( p2 ) ;
                        } ;
                        cb.Callback = newCbAction ;
                        // var ret = CreateCallbackProxy ( _proxyGenerator , cbAction , cb ) ;
                        // invocation.ReturnValue = ret ;
                        i.ReturnValue = invocation.ReturnValue ;
                        return ;
                    }
                    
                    var classProxyWithTarget =
                        Generator.CreateClassProxyWithTarget (
                                                                    invocation.ReturnValue
                                                                  , new BuilderInterceptor (
                                                                                            Generator
                                                                                           )
                                                                   ) ;
                    invocation.ReturnValue = classProxyWithTarget ;
                }
                catch ( Exception ex )
                {
                    Logger.Warn ( ex , ex.Message ) ;
                }
            }
        }

        // ReSharper disable once UnusedMember.Local
        private static object CreateCallbackProxy (
            ProxyGenerator                proxyGenerator
          , Action < IComponentRegistry > callback
           ,
            // ReSharper disable once UnusedParameter.Global
            // ReSharper disable once UnusedParameter.Local
            DeferredCallback defer
        )

        {
            Logger.Info ( "Creating deffered callback proxy" ) ;
            var x = proxyGenerator.CreateClassProxy (
                                                     typeof ( DeferredCallback )
                                                   , new ProxyGenerationOptions (
                                                                                 new
                                                                                     CallBackHook ( )
                                                                                )
                                                   , new object[] { callback }
                                                   , new CallbackInterceptor ( proxyGenerator)
                                                    ) ;
            return x ;
        }

        /// <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        public BuilderInterceptor ( ProxyGenerator generator ) : base ( generator )
        {
        }
    }

    /// <summary></summary>
    /// <seealso cref="Castle.DynamicProxy.IInterceptor" />
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for RegistryInterceptor
    public class RegistryInterceptor : BaseInterceptor
    {
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger ( ) ;

        /// <summary>Intercepts the specified invocation.</summary>
        /// <param name="invocation">The invocation.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Intercept
        public override void Intercept ( IInvocation invocation )
        {
            Logger.Info ( invocation.Method.Name ) ;
            for ( var i = 0 ; i < invocation.Arguments.Length ; i ++ )
            {
                var arg = invocation.Arguments[ i ] ;
                if ( arg is Delegate d )
                {
                    DumpDelegate ( d , $"[{i}]" ) ;
                }
                else
                {
                    Logger.Info ( $"[{i}] {NameForType ( arg.GetType ( ) )}" ) ;
                    Logger.Info ( $"[{i}]: = {arg}" ) ;
                }
            }

            if ( invocation.Arguments.Any ( ) )
            {
                // Logger.Warn (
                // string.Join (
                // ", "
                // , invocation.Arguments.Select ( o => o.ToString ( ) )
                // )
                // ) ;
            }

            invocation.Proceed ( ) ;
        }

        /// <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        public RegistryInterceptor ( ProxyGenerator generator ) : base ( generator )
        {
        }
    }

    internal class CallBackHook : IProxyGenerationHook
    {
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger ( ) ;

        /// <summary>
        ///   Invoked by the generation process to notify that the whole process has completed.
        /// </summary>
        public void MethodsInspected ( ) { }

        /// <summary>
        ///   Invoked by the generation process to notify that a member was not marked as virtual.
        /// </summary>
        /// <param name="type">The type which declares the non-virtual member.</param>
        /// <param name="memberInfo">The non-virtual member.</param>
        /// <remarks>
        ///   This method gives an opportunity to inspect any non-proxyable member of a type that has
        ///   been requested to be proxied, and if appropriate - throw an exception to notify the caller.
        /// </remarks>
        public void NonProxyableMemberNotification ( Type type , MemberInfo memberInfo )
        {
            Logger.Error ( $"cant proxy {memberInfo.Name}" ) ;
        }

        /// <summary>
        ///   Invoked by the generation process to determine if the specified method should be proxied.
        /// </summary>
        /// <param name="type">The type which declares the given method.</param>
        /// <param name="methodInfo">The method to inspect.</param>
        /// <returns>True if the given method should be proxied; false otherwise.</returns>
        public bool ShouldInterceptMethod ( Type type , MethodInfo methodInfo )
        {
            Logger.Error ( $"can proxy {methodInfo.Name}" ) ;
            return true ;
        }
    }

    internal class CallbackInterceptor : BaseInterceptor
    {
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger ( ) ;

        public override void Intercept ( IInvocation invocation )
        {
            Logger.Warn ( "callback " + invocation.Method.Name ) ;
            Logger.Warn (
                         string.Join ( ", " , invocation.Arguments.Select ( o => o.ToString ( ) ) )
                        ) ;
        }

        /// <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        public CallbackInterceptor ( ProxyGenerator generator ) : base ( generator )
        {
        }
    }
}