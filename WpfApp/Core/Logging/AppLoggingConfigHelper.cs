using System ;
using System.Linq ;
using DynamicData ;
using System.Collections.Generic ;
using System.Diagnostics ;
using System.IO ;
using System.Linq ;
using System.Reflection ;
using System.Runtime.CompilerServices ;
using System.Text ;
using System.Text.RegularExpressions ;
using Castle.DynamicProxy ;
using DynamicData ;
using JetBrains.Annotations ;
using NLog ;
using NLog.Common ;
using NLog.Config ;
using NLog.Fluent ;
using NLog.Layouts ;
using NLog.Targets ;
using NLog.Targets.Wrappers ;

namespace WpfApp.Core.Logging
{
    /// <summary></summary>
    /// <seealso cref="NLog.Config.LoggingConfiguration" />
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for AppLoggingConfigHelper
    /// TODO should not use inheritance
    // ReSharper disable once ClassNeverInstantiated.Global
    public class AppLoggingConfigHelper
    {
        /// <summary>The string writer</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for StringWriter
        public static StringWriter StringWriter ;

        private static Logger     Logger ;

        [ ThreadStatic ]
        private static int ? _numTimesConfigured ;


        /// <summary>Gets or sets the log factory.</summary>
        /// <value>The log factory.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for logFactory
        public LogFactory logFactory { get ; set ; }

        /// <summary>Gets or sets a value indicating whether [debugger target enabled].</summary>
        /// <value>
        ///   <c>true</c> if [debugger target enabled]; otherwise, <c>false</c>.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for DebuggerTargetEnabled
        public static bool DebuggerTargetEnabled { get ; set ; } = false ;


        /// <summary>Gets or sets a value indicating whether [logging is configured].</summary>
        /// <value>
        ///   <c>true</c> if [logging is configured]; otherwise, <c>false</c>.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for LoggingIsConfigured
        public static bool LoggingIsConfigured { get ; set ; }

        /// <summary>Gets or sets a value indicating whether [dump existing configuration].</summary>
        /// <value>
        ///   <c>true</c> if [dump existing configuration]; otherwise, <c>false</c>.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for DumpExistingConfig
        public static bool DumpExistingConfig { get ; set ; } = true ;


        /// <summary>Gets or sets a value indicating whether [force code configuration].</summary>
        /// <value>
        ///   <c>true</c> if [force code configuration]; otherwise, <c>false</c>.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for ForceCodeConfig
        public static bool ForceCodeConfig { get ; set ; } = false ;

        private static void DoLogMessage ( string message )
        {
            System.Diagnostics.Debug.WriteLine (
                                                nameof ( AppLoggingConfigHelper ) + ":" + message
                                               ) ;
            // System.Diagnostics.Debug.WriteLine ( nameof(AppLoggingConfigHelper) + ":" + message ) ;
        }

        // ReSharper disable once MemberCanBePrivate.Global
        internal static void ConfigureLogging (
            LogDelegates.LogMethod logMethod
          , bool                   proxyLogging = false
        )
        {
            logMethod ( "*** Starting logger configuration." ) ;
            InternalLogging ( ) ;

            LogFactory proxiedFactory = null ;
            if ( proxyLogging )
            {
                var proxyGenerator = new ProxyGenerator ( ) ;
                var loggerProxyHelper = new LoggerProxyHelper ( proxyGenerator , DoLogMessage ) ;
                var logFactory = new MyLogFactory ( DoLogMessage ) ;
                var lconfLogFactory = loggerProxyHelper.CreateLogFactory ( logFactory ) ;
                proxiedFactory = lconfLogFactory ;
            }

            var fieldInfo = typeof ( LogManager ).GetField (
                                                            "factory"
                                                          , BindingFlags.Static
                                                            | BindingFlags.NonPublic
                                                           ) ;
            if ( fieldInfo != null )
            {
                logMethod ( $"field info is {fieldInfo.DeclaringType} . {fieldInfo.Name}" ) ;
                var cur = fieldInfo.GetValue ( null ) ;
                logMethod ( $"cur is {cur}" ) ;

                if ( proxyLogging )
                {
                    fieldInfo.SetValue ( null , proxiedFactory ) ;
                    var newVal = fieldInfo.GetValue ( null ) ;
                    logMethod ( $"NewVal = {newVal}" ) ;
                }
            }

            var useFactory = proxyLogging ? proxiedFactory : LogManager.LogFactory ;
            var lconf = new CodeConfiguration ( useFactory ) ;
            var t = new List < Target > ( ) ;
            #region Cache Target
#if false
            var cacheTarget = new  MyCacheTarget ( ) ;
            t.Add ( cacheTarget );

#endif
            #endregion
            #region NLogViewer Target
            var viewer = Viewer ( ) ;
            t.Add ( viewer ) ;
            #endregion
            #region Debugger Target
            if ( DebuggerTargetEnabled )
            {
                var debuggerTarget =
                    new DebuggerTarget { Layout = new SimpleLayout ( "${message}" ) } ;
                t.Add ( debuggerTarget ) ;
            }
            #endregion
            #region Chainsaw Target
            var chainsawTarget = new ChainsawTarget ( ) ;
            SetupNetworkTarget ( chainsawTarget , "udp://192.168.10.1:4445" ) ;
            t.Add ( chainsawTarget ) ;
            #endregion
            t.Add ( MyFileTarget ( ) ) ;
            var jsonFileTarget = JsonFileTarget ( ) ;
            t.Add ( jsonFileTarget ) ;
            var byType = new Dictionary < Type , int > ( ) ;
            foreach ( var target in t )
            {
                // logMethod ( $"target is {target}" ) ;
                var type = target.GetType ( ) ;
                byType.TryGetValue ( type , out var count ) ;
                count          += 1 ;
                byType[ type ] =  count ;

                if ( target.Name == null )
                {
                    target.Name = $"{Regex.Replace ( type.Name , "Target" , "" )}{count:D2}" ;
                }

                lconf.AddTarget ( target ) ;//new AsyncTargetWrapper(target.Name + "AsyncWrapper", target)) ;
            }

            var loggingRules = t.AsQueryable ( ).AsEnumerable ( ).Select ( DefaultLoggingRule ) ;
            foreach ( var loggingRule in loggingRules ) { lconf.LoggingRules.Add ( loggingRule ) ; }

            LogManager.Configuration = lconf ;
            Logger                   = LogManager.GetCurrentClassLogger ( ) ;
        }

        private static LoggingRule DefaultLoggingRule ( Target target )
        {
            return new LoggingRule ( "*" , LogLevel.FromOrdinal ( 0 ) , target ) ;
        }

        private static void InternalLogging ( )
        {
            InternalLogger.LogLevel = LogLevel.Debug ;

            var id = Process.GetCurrentProcess ( ).Id ;
            var logFile = $@"c:\temp\nlog-internal-{id}.txt" ;
            InternalLogger.LogFile = logFile ;

            //InternalLogger.LogToConsole      = true ;
            //InternalLogger.LogToConsoleError = true ;
            //InternalLogger.LogToTrace        = true ;

            StringWriter             = new StringWriter ( ) ;
            InternalLogger.LogWriter = StringWriter ;
        }

        private static void SetupNetworkTarget ( NetworkTarget target , string address )
        {
            target.Address = new SimpleLayout ( address ) ;
        }

        private static NLogViewerTarget Viewer ( string name = null )
        {
            return new NLogViewerTarget ( name )
                   {
                       Address              = new SimpleLayout ( "udp://10.25.0.102:9999" )
                     , IncludeAllProperties = true
                     , IncludeCallSite      = true
                     , IncludeSourceInfo    = true
                   } ;
        }

        /// <summary>Jsons the file target.</summary>
        /// <returns></returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for JsonFileTarget
        public static FileTarget JsonFileTarget ( )
        {
            var f = new FileTarget ( "json_out" )
                    {
                        FileName = Layout.FromString ( @"c:\data\logs\test.json" )
                    } ;

            f.Layout = SetupJsonLayout ( ) ;
            return f ;
        }

        /// <summary>Mies the file target.</summary>
        /// <returns></returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for MyFileTarget
        public static FileTarget MyFileTarget ( )
        {
            var f = new FileTarget
                    {
                        Name     = "text_log"
                      , FileName = Layout.FromString ( @"c:\data\logs\log.txt" )
                      , Layout   = Layout.FromString ( "${message}" )
                    } ;

            return f ;
        }

        /// <summary>Removes the target.</summary>
        /// <param name="target">The target.</param>
        /// <exception cref="System.ArgumentNullException">target</exception>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for RemoveTarget
        public static void RemoveTarget ( [ NotNull ] Target target )
        {
            if ( target == null )
            {
                throw new ArgumentNullException ( nameof ( target ) ) ;
            }

            Logger.Debug ( "Removing target " + target) ;
            LogManager.Configuration.RemoveTarget ( target.Name ) ;
            LogManager.LogFactory.ReconfigExistingLoggers ( ) ;
            foreach (var t in LogManager.Configuration.AllTargets)
            {
                Logger.Debug("Target " + t);
            }

        }

        /// <summary>Ensures the logging configured.</summary>
        /// <param name="logMethod">The log method.</param>
        /// <param name="callerFilePath">The caller file path.</param>
        /// <exception cref="Exception">no config loaded field found</exception>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for EnsureLoggingConfigured
        public static void EnsureLoggingConfigured (
            LogDelegates.LogMethod    logMethod      = null
          , [ CallerFilePath ] string callerFilePath = null
        )
        {
            if ( ! _numTimesConfigured.HasValue )
            {
                _numTimesConfigured = 1 ;
            }
            else
            {
                _numTimesConfigured += 1 ;
            }

            if ( logMethod == null )
            {
                logMethod = DoLogMessage ;
            }

            logMethod (
                       $"[time {_numTimesConfigured.Value}]\t{nameof ( EnsureLoggingConfigured )} called from {callerFilePath}"
                      ) ;


            var fieldInfo2 = LogManager.LogFactory.GetType ( )
                                       .GetField (
                                                  "_config"
                                                , BindingFlags.Instance | BindingFlags.NonPublic
                                                 ) ;

            if ( fieldInfo2 == null )
            {
                System.Diagnostics.Debug.WriteLine (
                                                    "no field _configLoaded for "
                                                    + LogManager.LogFactory
                                                   ) ;
                throw new Exception ( "no config loaded field found" ) ;
            }

            var config = fieldInfo2.GetValue ( LogManager.LogFactory ) ;

            //LogManager.ThrowConfigExceptions = true;
            //LogManager.ThrowExceptions = true;
            var fieldInfo = LogManager.LogFactory.GetType ( )
                                      .GetField (
                                                 "_configLoaded"
                                               , BindingFlags.Instance | BindingFlags.NonPublic
                                                ) ;

            bool configLoaded ;
            if ( fieldInfo == null )
            {
                configLoaded = config != null ;

                System.Diagnostics.Debug.WriteLine (
                                                    "no field _configLoaded for "
                                                    + LogManager.LogFactory
                                                   ) ;
                // throw new Exception ( "no config loaded field found" ) ;
            }
            else
            {
                configLoaded = ( bool ) fieldInfo.GetValue ( LogManager.LogFactory ) ;
            }

            LoggingIsConfigured = configLoaded ;
            var isMyConfig = ! configLoaded      || LogManager.Configuration is CodeConfiguration ;
            var doConfig = ! LoggingIsConfigured || ForceCodeConfig && ! isMyConfig ;
            logMethod (
                       $"{nameof ( LoggingIsConfigured )} = {LoggingIsConfigured}; {nameof ( ForceCodeConfig )} = {ForceCodeConfig}; {nameof ( isMyConfig )} = {isMyConfig});"
                      ) ;
            if ( DumpExistingConfig )
            {
                Action < string > collect = s_ => {
                    System.Diagnostics.Debug.WriteLine ( s_ ) ;
                } ;
                DoDumpConfig ( collect ) ;
            }

            if ( doConfig )
            {
                ConfigureLogging ( logMethod ) ;
                return ;
            }

            // if ( LogManager.Configuration == null )
            // {
            // 	ConfigureLogging (logMethod ) ;
            // }

            DumpPossibleConfig ( LogManager.Configuration ) ;
        }

        private static void DoDumpConfig ( Action < string > collect )
        {
            var config = LogManager.Configuration ;
            if ( config == null )
            {
                return ;
            }

            foreach ( var unused in config.AllTargets )
            {
                foreach ( var aTarget in config.AllTargets )
                {
                    collect ( aTarget.Name ) ;
                    collect ( aTarget.GetType ( ).ToString ( ) ) ;
                    if ( aTarget is TargetWithLayout a )
                    {
                        if ( a.Layout is JsonLayout jl )
                        {
                            string Selector ( JsonAttribute attribute , int i )
                            {
                                if ( attribute == null )
                                {
                                    throw new ArgumentNullException ( nameof ( attribute ) ) ;
                                }

                                var b = new StringBuilder ( ) ;
                                var propertyInfos = attribute
                                                   .GetType ( )
                                                   .GetProperties (
                                                                   BindingFlags.Public
                                                                   | BindingFlags.Instance
                                                                  ) ;
                                foreach ( var propertyInfo in propertyInfos )
                                {
                                    var val2 = propertyInfo.GetValue ( attribute ) ;
                                    b.Append ( $"{propertyInfo.Name} = {val2}; " ) ;
                                }

                                return b.ToString ( ) ;
                            }

                            var enumerable = jl.Attributes.Select ( Selector ) ;
                            collect ( string.Join ( "--" , enumerable ) ) ;
                        }
                    }

                    if ( aTarget is FileTarget gt )
                    {
                        collect ( gt.FileName.ToString ( ) ) ;
                    }
                }
            }
        }


        private static void DumpPossibleConfig ( LoggingConfiguration configuration )
        {
            var candidateConfigFilePaths = LogManager.LogFactory.GetCandidateConfigFilePaths ( ) ;
            foreach ( var q in candidateConfigFilePaths )
            {
                Debug ( $"{q}" ) ;
            }

            var fieldInfo = configuration.GetType ( )
                                         .GetField (
                                                    "_originalFileName"
                                                  , BindingFlags.NonPublic | BindingFlags.Instance
                                                   ) ;
            if ( fieldInfo != null )
            {
                if ( fieldInfo.GetValue ( configuration ) != null )
                {
                    {
                        Debug ( "Original NLog configuration filename" ) ;
                    }
                }
            }

            Debug ( $"{configuration}" ) ;
        }


        // ReSharper disable once UnusedParameter.Local
        private static void Debug ( string s ) { }

        // public static  Func < bool > EnsureLoggingConfigured = () => true ;
        /// <summary>Adds the target.</summary>
        /// <param name="target">The target.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for AddTarget
        public static void AddTarget ( Target target )
        {
            // EnsureLoggingConfigured();
            // new LogBuilder ( Logger ).Level ( LogLevel.Debug )
            // .Message (
            // $"Adding target {target.Name} {target.GetType ( ).FullName}"
            // )
            // .Write ( ) ;

            if ( LogManager.Configuration != null )
            {
                LogManager.Configuration.AddTarget ( target ) ;
                var rule = DefaultLoggingRule ( target ) ;
                LogManager.Configuration.AddRule (
                                                  LogLevel.Trace
                                                , LogLevel.Fatal
                                                , target
                                                , "*"
                                                 ) ;
            }

            LogManager.LogFactory.ReconfigExistingLoggers ( ) ;

        }

        /// <summary>Removes the target.</summary>
        /// <param name="name">The name.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for RemoveTarget
        public static void RemoveTarget ( string name )
        {
            LogManager.Configuration.RemoveTarget ( name ) ;
            LogManager.Configuration.LogFactory.ReconfigExistingLoggers ( ) ;
        }

        /// <summary>Setups the json layout.</summary>
        /// <returns></returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for SetupJsonLayout
        public static JsonLayout SetupJsonLayout ( )
        {
            Tuple < string , string >[] atts = new Tuple < string , string >[]
                                               {
                                                   Tuple.Create ( "logger" ,   (string)null )
                                                 , Tuple.Create ( "@t" , "${longdate}" )
                                                 , Tuple.Create ( "logger" , (string)null)
                                                 , Tuple.Create ( "@mt" , "${message}")
                                                 , Tuple.Create ( "exception" , "${exception}")
                                               } ;

            
            var l = new JsonLayout { IncludeAllProperties = true } ;
            l.Attributes.AddRange (
                                   atts.Select (
                                                tuple => new JsonAttribute (
                                                                            tuple.Item1
                                                                          , Layout.FromString (
                                                                                               tuple
                                                                                                  .Item2
                                                                                               == null
                                                                                                   ? $"${{{tuple.Item1}}}"
                                                                                                   : tuple
                                                                                                      .Item2
                                                                                              )
                                                                           )
                                               )
                                  ) ;

            return l ;
        }
    }
}