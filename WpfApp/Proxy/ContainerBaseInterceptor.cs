#region header
// Kay McCormick (mccor)
// 
// WpfApp
// WpfApp
// BaseInterceptor.cs
// 
// 2020-02-06-9:56 PM
// 
// ---
#endregion
using System ;
using System.CodeDom ;
using System.Linq ;
using System.Runtime.CompilerServices ;
using Castle.DynamicProxy ;
using JetBrains.Annotations ;
using Microsoft.CSharp ;
using NJection.LambdaConverter.Fluent ;
using NLog ;

namespace WpfApp.Proxy
{
    /// <summary></summary>
    /// <seealso cref="Castle.DynamicProxy.IInterceptor" />
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for BaseInterceptor
    public abstract class ContainerBaseInterceptor : IInterceptor
    {
        /// <summary>Gets the generator.</summary>
        /// <value>The generator.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Generator
        // ReSharper disable once UnusedAutoPropertyAccessor.Global
        protected ProxyGenerator Generator { get ; }

        private static readonly Logger Logger = LogManager.GetCurrentClassLogger ( ) ;

        /// <summary>Initializes a new instance of the <see cref="System.Object" /> class.</summary>
        protected ContainerBaseInterceptor (ProxyGenerator generator) { Generator = generator ; }

        /// <summary>Dumps the delegate.</summary>
        /// <param name="d">The d.</param>
        /// <param name="prefix">Prefix to prepend to log messages</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for DumpDelegate
        protected void DumpDelegate ( Delegate d , string prefix = "" )
        {
            try
            {
                var expression = Lambda.TransformMethodTo < Delegate > ( )
                                       .From ( ( ) => d )
                                       .ToLambda ( ) ;
                Logger.Debug ( $"{expression}" ) ;
            }
            catch ( Exception )
            {
                // ignored
            }

            var typeDesc = NameForType ( d.Target.GetType ( ) ) ;
            var methodInfo = d.Method ;
            var g = methodInfo.IsGenericMethod ;
            var s = methodInfo.IsSpecialName ;
            foreach ( var att in methodInfo.CustomAttributes )
            {
                Logger.Info ( $"{prefix}{att}" ) ;
            }

            if ( methodInfo.CustomAttributes.Any (
                                                  data => data.AttributeType
                                                          == typeof ( CompilerGeneratedAttribute )
                                                 ) )
            {
                Logger.Info ( "compiler generated" ) ;
            }

            Logger.Info ( $"{prefix}Delegate: {s} {g} {typeDesc} {methodInfo.Name}" ) ;
        }

        /// <summary>Names for type.</summary>
        /// <param name="myType">My type.</param>
        /// <returns></returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for NameForType
        protected string NameForType ( [ NotNull ] Type myType )
        {
            if ( myType == null )
            {
                throw new ArgumentNullException ( nameof ( myType ) ) ;
            }

            var provider = new CSharpCodeProvider ( ) ;
            if ( myType.IsGenericType )
            {
                var type = myType.GetGenericTypeDefinition ( ) ;
                myType = type ;
            }

            var codeTypeReference = new CodeTypeReference ( myType ) ;
            var q = codeTypeReference ;
            //myType.GetGenericTypeParameters()
            return provider.GetTypeOutput ( q ) ;
            // return myType.IsGenericType ? myType.GetGenericTypeDefinition ( ).Name : myType.Name ;
        }

        /// <summary>Intercepts the specified invocation.</summary>
        /// <param name="invocation">The invocation.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Intercept
        public abstract void Intercept ( IInvocation invocation ) ;
    }
}