using System ;
using System.Collections.Generic ;
using System.ComponentModel ;
using System.Linq ;
using System.Xaml ;
using Castle.DynamicProxy ;
using JetBrains.Annotations ;

namespace WpfApp.Proxy
{
    /// <summary></summary>
    /// <seealso cref="Castle.DynamicProxy.IInterceptor" />
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for BaseInterceptor
    [Browsable(false)]
    public abstract class BaseInterceptor : IInterceptor
    {
        /// <summary>Gets the proxy generator.</summary>
        /// <value>The proxy generator.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for ProxyGenerator
        protected ProxyGenerator ProxyGenerator { get ; }

        /// <summary>The write</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Write
        protected readonly Action < string > Write = null ;

        /// <summary>The write line</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for WriteLine
        protected Action < string > WriteLine ;

        /// <summary>Initializes a new instance of the <see cref="BaseInterceptor"/> class.</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for #ctor
        protected BaseInterceptor ( ProxyGenerator proxyGenerator )
        {
            ProxyGenerator = proxyGenerator ;
        }

        /// <summary>Dumps the invocation.</summary>
        /// <param name="invocation">The invocation.</param>
        /// <param name="callDepth">The call depth.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for DumpInvocation
        protected void DumpInvocation ( [ NotNull ] IInvocation invocation , int callDepth )
        {
            if ( invocation == null )
            {
                throw new ArgumentNullException ( nameof ( invocation ) ) ;
            }

            var c = Depth ( callDepth ) ;

            var f = FormatInvocation ( invocation , c ) ;
            if ( Write == null )
            {
                WriteLine ( f ) ;
            }
            else
            {
                Write ( f ) ;
            }
        }


        private string FormatInvocation ( IInvocation invocation , string c )
        {
            var args = invocation.Method.IsSpecialName && invocation.Arguments.Length == 0
                           ? ""
                           :
                           invocation.Arguments.Length == 0
                               ?
                               "( )"
                               : "("
                                 + string.Join (
                                                ", "
                                              , invocation
                                               .Arguments.Select (
                                                                  ( o , i ) => FormatArgument (
                                                                                               invocation
                                                                                             , o
                                                                                             , i
                                                                                              )
                                                                 )
                                               .ToArray ( )
                                               )
                                         .PadRight ( 40 )
                                 + " )" ;
            return c + "\t" + MethodSpec ( invocation ) + args ;
        }

        private string FormatArgument ( IInvocation invocation , object arg1 , int arg2 )
        {
            var q = FormatTypeAndValue ( arg1 ) ;
            var name = invocation.Method.GetParameters ( )[ arg2 ].Name ;
            return $"{name}: {q}" ;
        }

        private string FormatTypeAndValue ( object o )
        {
            if ( o == null )
            {
                return "null" ;
            }

            var type = FormatTyp ( o.GetType ( ) ) + " " ;

            if ( o is Type )
            {
                type = "" ;
            }

            var formatValue = FormatValue ( o , out var wantType ) ;
            return wantType ? $"{type}{formatValue}" : formatValue ;
        }

        private static string Depth ( int callDepth )
        {
            var c = '⟳' ;
            return $"{new string ( c , callDepth ),- 8}" ;
            //return char.ConvertFromUtf32 ( 0x2460 + callDepth - 1 ) ;
        }

        /// <summary>Dumps the return value.</summary>
        /// <param name="invocation">The invocation.</param>
        /// <param name="callDepth">The call depth.</param>
        /// <param name="continuation">if set to <c>true</c> [continuation].</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for DumpReturnValue
        protected void DumpReturnValue (
            IInvocation invocation
          , int         callDepth
          , bool        continuation
        )
        {
            var c = Depth ( callDepth ) ;
            if ( invocation.ReturnValue != null )
            {
                var f = ( continuation
                              ? ""
                              : c
                                + "\t"
                                + MethodSpec ( invocation )
                                + "\t"
                                + //invocation.TargetType + "."+ invocation.Method.Name +
                                "\t\t" )
                        + " ➦ "
                        + FormatReturnValue ( invocation , invocation.ReturnValue ) ;
                WriteLine ( f ) ;
            }
        }

        // ReSharper disable once UnusedParameter.Local
        private string FormatReturnValue ( IInvocation invocation , object r )
        {
            return FormatValue ( r , out _ ) ;
        }

        private static string FormatValue ( object r , out bool b1 )
        {
            b1 = false ;
            if ( r is bool b )
            {
                var val = b ? "⊨" : "⊭" ;
                return val ;
            }
            else if ( r is Type t )
            {
                var rr = t.UnderlyingSystemType == t ? "" : "𝓡" ;
                return $"{rr}𝒯 {FormatTyp ( t.UnderlyingSystemType )}" ;
            }
            else if ( r is XamlType xt )
            {
                return "𝓧" + FormatValue ( xt.UnderlyingType , out b1 ) ;
            }
            else if ( r is string ss )
            {
                return ss ;
            }
            else
            {
                if ( r is ICollection < object > col )
                {
                    var q = from o in col select FormatValue ( o , out b ) ;
                    b1 = true ;
                    return string.Join ( ", " , q ) ;
                }
            }

            b1 = true ;
            return r.ToString ( ) ;
        }

        // ReSharper disable once UnusedMember.Local
        private static string FormatValue < T > ( ICollection < T > r , out bool b1 )
        {
            b1 = true ;
            return string.Join ( ", " , r.Select ( v => FormatValue ( v , out _ ) ) ) ;
        }

        /// <summary>Formats the typ.</summary>
        /// <param name="type">The type.</param>
        /// <returns></returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for FormatTyp
        protected static string FormatTyp ( Type type )
        {
            if ( type.IsGenericType )
            {
                return FormatConstructedGenericType ( type ) ;
            }

            var typeName = type.Name ;
            return Alter ( typeName ) ;
        }

        private static string FormatConstructedGenericType ( Type type )
        {
            var type2 = type.GetGenericTypeDefinition ( ) ;
            return Alter (
                          $"{type2.Name}<{string.Join ( "," , type.GenericTypeArguments.Select ( ( type1 , i ) => FormatTyp ( type1 ) ) )}>"
                         ) ;
        }

        private static string Alter ( string s )
        {
            return s.Replace ( "<" , " 〈 " )
                    .Replace ( ">" , " 〉 " )
                    .Replace ( "[" , " 【 " )
                    .Replace ( "]" , " 】 " )
                    .Replace ( "`" , "❛" ) ;
        }

        private static string MethodSpec ( IInvocation invocation )
        {
            var declType = invocation.Method.DeclaringType ;
            var formatTyp = FormatTyp ( declType ) ;
            var type = invocation.TargetType ;
            var typ = FormatTyp ( type ) ;

            var m = " " + invocation.Method.Name ;
            if ( invocation.Method.IsSpecialName
                 && invocation.Method.Name.StartsWith ( "get_" ) )
            {
                m = $"𝜙 {invocation.Method.Name.Substring ( 4 )}" ;
            }

            return ( declType == type ? $"{formatTyp,33}" : $"{formatTyp,16} {typ,16}" ) + " " + m ;
        }

        /// <summary>Intercepts the specified invocation.</summary>
        /// <param name="invocation">The invocation.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Intercept
        public abstract void Intercept ( IInvocation invocation ) ;
    }
}