using System;
using System.Text.RegularExpressions ;
using System.Windows ;
using NLog;
using NLog.Layouts;
using Tests.Lib ;
using Tests.Lib.Fixtures;
using WpfApp ;
using WpfApp.Application;
using WpfApp.Core.Container;
using WpfApp.Core.Utils;
using WpfApp.Debug;
using WpfApp.Proxy;
using Xunit;
using Xunit.Abstractions;

namespace Tests.Main
{
    /// <summary>Tests for primary application class <see cref="App"/>.</summary>
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for AppTests
    [Collection("GeneralPurpose")]
    public class TestProps : IClassFixture<LoggingFixture>, IDisposable
    {
        private static Logger Logger = LogManager.GetCurrentClassLogger();
        private readonly ITestOutputHelper _output;
        private readonly LoggingFixture _loggingFixture;

        /// <summary>Initializes a new instance of the <see cref="T:System.Object" /> class.</summary>
        public TestProps(ITestOutputHelper output, LoggingFixture loggingFixture)
        {
            _output = output;
            _loggingFixture = loggingFixture;
            loggingFixture.SetOutputHelper(output);
            _loggingFixture.Layout = Layout.FromString("${message}");
        }

        /// <summary>Tests the props configured.</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for TestPropsConfigured
        [WpfFact]
        public void TestPropsConfigured()
        {
            Type t = typeof ( Props ) ;
            foreach ( var fieldInfo in t.GetFields ( ) )
            {
                if ( ! fieldInfo.IsStatic )
                {
                    Logger.Error (
                                  "Discovered non-static field {fieldName} on {type}"
                                , fieldInfo.Name
                                , fieldInfo.DeclaringType
                                 ) ;
                    continue ;
                }

                object value = fieldInfo.GetValue ( null ) ;
                if(value is DependencyProperty prop)
                {
                    Assert.IsAssignableFrom < DependencyProperty > ( value ) ;
                    Assert.EndsWith ( "Property" , fieldInfo.Name ) ;
                    var name = fieldInfo.Name.Substring ( 0, fieldInfo.Name.Length - 8 ) ;
                    Assert.Equal ( name , prop.Name ) ;

                } else if ( typeof ( RoutedEvent ).IsAssignableFrom ( fieldInfo.FieldType ))
                {
                    RoutedEvent @event = value as RoutedEvent ;
                    bool isEvent = true ;
                    Assert.EndsWith ( "Event" , fieldInfo.Name ) ;
                    var name = fieldInfo.Name.Substring(0, fieldInfo.Name.Length - 5);
                    Assert.Equal ( name , @event.Name ) ;

                }
                else
                {
                    throw new UnexpectedPropertyException ( "Unexpected property" , fieldInfo ) ;
                }
                Logger.Debug ( "{fieldName} {type}" , fieldInfo.Name , fieldInfo.FieldType ) ;
            }
        }



        private void DebugEventHandler(object sender, DebugEventArgs e)
        {
            _output.WriteLine(e.Message);
        }

        /// <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        public void Dispose()
        {
            // _loggingFixture?.Dispose ( ) ;
            _loggingFixture.SetOutputHelper(null);
        }
    }
}