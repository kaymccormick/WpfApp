#region header
// Kay McCormick (mccor)
// 
// FileFinder3
// WpfApp1Tests3
// ContainerFixture.cs
// 
// 2020-01-19-5:59 PM
// 
// ---
#endregion

using System ;
using System.Collections.Generic ;
using System.Threading.Tasks ;
using Autofac ;
using Autofac.Core ;
using Autofac.Core.Lifetime ;
using Autofac.Core.Resolving ;
using JetBrains.Annotations ;
using NLog ;
using WpfApp.Core.Container ;
using Xunit ;
using Xunit.Abstractions ;

namespace Tests.Lib.Fixtures
{
    /// <summary>Test fixture configured to supply the primary application container from Autofac.</summary>
    /// <seealso cref="Xunit.IAsyncLifetime" />
    /// <seealso cref="ContainerHelper"/>
    [UsedImplicitly ]
    public class AppContainerFixture : IAsyncLifetime, ILifetimeScope
    {
        private readonly IMessageSink _sink ;

        // ReSharper disable once UnusedMember.Local
        // ReSharper disable once InternalOrPrivateMemberNotDocumented
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger ( ) ;

        /// <summary>The container</summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for _container
        private ILifetimeScope _container = null ;

        /// <summary>
        ///     Initializes a new instance of the <see cref="T:System.Object" />
        ///     class.
        /// </summary>
        public AppContainerFixture ( IMessageSink sink )
        {
            _sink = sink ;
            FixtureLogger.LogFixtureCreatedLifecycleEvent(GetType());

        }

        /// <summary>Gets the lifetime scope.</summary>
        /// <value>The lifetime scope.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for LifetimeScope
        protected ILifetimeScope LifetimeScope { get ; set ; }


        /// <summary>
        ///     Called immediately after the class has been created, before it is used.
        /// </summary>
        public Task InitializeAsync ( )
        {
            _sink.OnMessage ( new DiagnosticMessage ( "Initializing container." ) ) ;
            LifetimeScope = ContainerHelper.SetupContainer(out _, null, null);
            return Task.CompletedTask ;
        }


        /// <summary>
        ///     Called when an object is no longer needed. Called just before
        ///     <see cref="M:System.IDisposable.Dispose" />
        ///     if the class also implements that.
        /// </summary>
        public Task DisposeAsync ( )
        {
            LifetimeScope?.Dispose ( ) ;
            _container?.Dispose ( ) ;
            return Task.CompletedTask ;
        }

        /// <summary>
        /// Resolve an instance of the provided registration within the context.
        /// </summary>
        /// <param name="registration">The registration.</param>
        /// <param name="parameters">Parameters for the instance.</param>
        /// <returns>The component instance.</returns>
        /// <exception cref="T:Autofac.Core.Registration.ComponentNotRegisteredException" />
        /// <exception cref="T:Autofac.Core.DependencyResolutionException" />
        public object ResolveComponent ( IComponentRegistration registration , IEnumerable < Parameter > parameters ) { return LifetimeScope.ResolveComponent ( registration , parameters ) ; }

        /// <summary>
        /// Gets the associated services with the components that provide them.
        /// </summary>
        public IComponentRegistry ComponentRegistry
        {
            get => LifetimeScope.ComponentRegistry ;
        }

        /// <summary>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</summary>
        public void Dispose ( )
        {
            FixtureLogger.LogFixtureFinalizedLifecycleEvent(GetType());
            LifetimeScope.Dispose ( ) ;
        }

        /// <summary>
        /// Begin a new nested scope. Component instances created via the new scope
        /// will be disposed along with it.
        /// </summary>
        /// <returns>A new lifetime scope.</returns>
        public ILifetimeScope BeginLifetimeScope ( ) { return LifetimeScope.BeginLifetimeScope ( ) ; }

        /// <summary>
        /// Begin a new nested scope. Component instances created via the new scope
        /// will be disposed along with it.
        /// </summary>
        /// <param name="tag">The tag applied to the <see cref="T:Autofac.ILifetimeScope" />.</param>
        /// <returns>A new lifetime scope.</returns>
        public ILifetimeScope BeginLifetimeScope ( object tag ) { return LifetimeScope.BeginLifetimeScope ( tag ) ; }

        /// <summary>
        /// Begin a new nested scope, with additional components available to it.
        /// Component instances created via the new scope
        /// will be disposed along with it.
        /// </summary>
        /// <remarks>
        /// The components registered in the sub-scope will be treated as though they were
        /// registered in the root scope, i.e., SingleInstance() components will live as long
        /// as the root scope.
        /// </remarks>
        /// <param name="configurationAction">Action on a <see cref="T:Autofac.ContainerBuilder" />
        /// that adds component registrations visible only in the new scope.</param>
        /// <returns>A new lifetime scope.</returns>
        public ILifetimeScope BeginLifetimeScope ( Action < ContainerBuilder > configurationAction ) { return LifetimeScope.BeginLifetimeScope ( configurationAction ) ; }

        /// <summary>
        /// Begin a new nested scope, with additional components available to it.
        /// Component instances created via the new scope
        /// will be disposed along with it.
        /// </summary>
        /// <remarks>
        /// The components registered in the sub-scope will be treated as though they were
        /// registered in the root scope, i.e., SingleInstance() components will live as long
        /// as the root scope.
        /// </remarks>
        /// <param name="tag">The tag applied to the <see cref="T:Autofac.ILifetimeScope" />.</param>
        /// <param name="configurationAction">Action on a <see cref="T:Autofac.ContainerBuilder" />
        /// that adds component registrations visible only in the new scope.</param>
        /// <returns>A new lifetime scope.</returns>
        public ILifetimeScope BeginLifetimeScope ( object tag , Action < ContainerBuilder > configurationAction ) { return LifetimeScope.BeginLifetimeScope ( tag , configurationAction ) ; }

        /// <summary>
        /// Gets the disposer associated with this <see cref="T:Autofac.ILifetimeScope" />.
        /// Component instances can be associated with it manually if required.
        /// </summary>
        /// <remarks>Typical usage does not require interaction with this member- it
        /// is used when extending the container.</remarks>
        public IDisposer Disposer
        {
            get => LifetimeScope.Disposer ;
        }

        /// <summary>
        /// Gets the tag applied to the <see cref="T:Autofac.ILifetimeScope" />.
        /// </summary>
        /// <remarks>Tags allow a level in the lifetime hierarchy to be identified.
        /// In most applications, tags are not necessary.</remarks>
        /// <seealso cref="M:Autofac.Builder.IRegistrationBuilder`3.InstancePerMatchingLifetimeScope(System.Object[])" />
        public object Tag
        {
            get => LifetimeScope.Tag ;
      
        }

        /// <summary>
        /// Fired when a new scope based on the current scope is beginning.
        /// </summary>
        public event EventHandler < LifetimeScopeBeginningEventArgs > ChildLifetimeScopeBeginning
        {
            add => LifetimeScope.ChildLifetimeScopeBeginning += value ;
            remove => LifetimeScope.ChildLifetimeScopeBeginning -= value ;
        }

        /// <summary>Fired when this scope is ending.</summary>
        public event EventHandler < LifetimeScopeEndingEventArgs > CurrentScopeEnding
        {
            add => LifetimeScope.CurrentScopeEnding += value ;
            remove => LifetimeScope.CurrentScopeEnding -= value ;
        }

        /// <summary>
        /// Fired when a resolve operation is beginning in this scope.
        /// </summary>
        public event EventHandler < ResolveOperationBeginningEventArgs > ResolveOperationBeginning
        {
            add => LifetimeScope.ResolveOperationBeginning += value ;
            remove => LifetimeScope.ResolveOperationBeginning -= value ;
        }
    }
}
