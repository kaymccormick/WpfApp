using System ;
using System.Threading.Tasks ;
using System.Windows ;
using System.Windows.Markup ;
using System.Windows.Media ;
using System.Windows.Threading ;
using JetBrains.Annotations ;
using NLog ;
using Tests.Lib.Utils ;
using Xunit ;

namespace Tests.Lib.Fixtures
{
    /// <summary></summary>
    /// <seealso cref="Xunit.IAsyncLifetime" />
    /// <autogeneratedoc />
    /// TODO Edit XML Comment Template for WpfApplicationHelper
    public class WpfApplicationHelper : IAsyncLifetime
    {
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger ( ) ;


        // ReSharper disable once UnusedAutoPropertyAccessor.Global
        /// <summary>Gets or sets the base pack URI.</summary>
        /// <value>The base pack URI.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for BasePackUri
        public Uri BasePackUri { get ; set ; }


        /// <summary>Gets or sets my application.</summary>
        /// <value>My application.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for MyApp
        public Application MyApp { get ; set ; }

        // ReSharper disable once UnusedMember.Global
        /// <summary>Gets or sets the op.</summary>
        /// <value>The op.</value>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Op
        public DispatcherOperation Op { get ; set ; }

        /// <summary>
        ///     Called immediately after the class has been created, before it is used.
        /// </summary>
        public Task InitializeAsync ( )
        {
            Logger?.Debug ( $"{nameof ( InitializeAsync )}" ) ;
            return Task.CompletedTask ;
        }

        /// <summary>
        ///     Called when an object is no longer needed. Called just before
        ///     <see cref="M:System.IDisposable.Dispose" />
        ///     if the class also implements that.
        /// </summary>
        public Task DisposeAsync ( )
        {
            #if TCS
            var tcs = new TaskCompletionSource < bool > ( ) ;
            var s = new CancellationTokenSource ( ) ;
            var token = s.Token ;
            if ( MyApp?.Dispatcher != null )
            {
                var dispatcherOperation = MyApp.Dispatcher.InvokeAsync (
                                                                        ( ) => {
                                                                            Logger.Error (
                                                                                          "on dispatcher thread"
                                                                                         ) ;
                                                                            MyApp.Exit += (
                                                                                sender
                                                                              , args
                                                                            ) => {
                                                                                Logger.Error (
                                                                                              "exit handler"
                                                                                             ) ;
                                                                                Logger.Error (
                                                                                              "setting result to true"
                                                                                             ) ;
                                                                                tcs.SetResult (
                                                                                               true
                                                                                              ) ;
                                                                            } ;
                                                                            Logger.Error (
                                                                                          "calling shutdown"
                                                                                         ) ;
                                                                            MyApp.Shutdown ( ) ;
                                                                            Logger.Error (
                                                                                          "shutdown returned"
                                                                                         ) ;
                                                                        }
                                                                      , DispatcherPriority.Send
                                                                      , token
                                                                       ) ;
                return Task.WhenAny (
                                     Task.WhenAll ( dispatcherOperation.Task , tcs.Task )
                                   , Task.Delay ( 3000 )
                                    ) ;
            }

            Logger.Error ( "MyApp is null" ) ;
            #endif
            return Task.CompletedTask ;
        }
        //
        //         private Task CreateApplication ( Assembly theAssembly )
        //         {
        //             Application theApp ;
        //             App myApp = null ;
        //             if ( LoadRealApp )
        //             {
        //                 Logger?.Debug ( "Creating real app" ) ;
        //                 try
        //                 {
        //                     void doApp ( )
        //                     {
        //                         theApp              = myApp = new App ( ) ;
        //                         MyApp               = myApp ;
        //                         theApp.ShutdownMode = ShutdownMode.OnExplicitShutdown ;
        //                         theApp.Run ( ) ;
        //                     }
        //
        //                     myApp = new App ( ) ;
        //                     myApp.DoOnStartup ( Array.Empty<string> ( ) ) ;
        //                     return Task.CompletedTask ;
        //                 }
        //                 catch ( Exception ex )
        //                 {
        //                     Logger?.Error ( ex , ex.Message ) ;
        //
        //                     throw ex ;
        //                 }
        //
        // #if XX
        //                 Action < Application > runAction = application => application.Run ( ) ;
        //                 var dispatcherOperation =
        //                     myApp.Dispatcher.BeginInvoke ( DispatcherPriority.Send , runAction , myApp ) ;
        //                 Op = dispatcherOperation ;
        // #endif
        //
        //                 //myApp.AppInitialize();
        //                 // var thread = new Thread (
        //                 // o => {
        //                 // ( ( Application ) o ).Run ( ) ;
        //                 // }
        //                 // ) ;
        //                 // thread.Start(myApp);
        //             }
        //             else
        //             {
        //                 MyApp = new Application ( ) ;
        //                 return Task.CompletedTask ;
        //             }
        //         }
        //         //
        //         //
        //         // CurAssembly =
        //         // 		theAssembly ?? throw new ArgumentNullException ( nameof ( theAssembly ) ) ;
        //         //
        //         // 	var assemblyFullName = CurAssembly.FullName ;
        //         // 	var assPart = Uri.EscapeUriString ( CurAssembly.GetName ( ).Name ) ;
        //         // 	var uri = new Uri (
        //         // 	                   $"pack://application:,,,/{assPart};component/"
        //         // 	                 , UriKind.RelativeOrAbsolute
        //         // 	                  ) ;
        //         // 	BasePackUri = uri ;
        //         // 	System.Diagnostics.Debug.WriteLine ( "URI is " + BasePackUri ) ;
        //         // 	MyApp = theApp ;
        //         // 	return null ;
        //         // }

        //[Test(), Apartment(ApartmentState.STA)]
        // ReSharper disable once UnusedMember.Global
        /// <summary>Makes the window wrap.</summary>
        /// <param name="genericType">Type of the generic.</param>
        /// <param name="wrappedType">Type of the wrapped.</param>
        /// <exception cref="System.ArgumentNullException">genericType
        /// or
        /// wrappedType</exception>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for MakeWindowWrap
        public void MakeWindowWrap ( [ NotNull ] Type genericType , [ NotNull ] Type wrappedType )
        {
            if ( genericType == null )
            {
                throw new ArgumentNullException ( nameof ( genericType ) ) ;
            }

            if ( wrappedType == null )
            {
                throw new ArgumentNullException ( nameof ( wrappedType ) ) ;
            }

            try
            {
                var wrapType = genericType.MakeGenericType ( wrappedType ) ;
                var wrap = Activator.CreateInstance ( wrapType ) as WindowWrap < Visual > ;
                MyApp.Run ( wrap ) ;
            }
            catch ( XamlParseException e )
            {
                Console.WriteLine ( e.Message ) ;
                throw ;
            }
            catch ( Exception e )
            {
                Logger.Debug ( e , $"{e.Message}" ) ;
                Console.WriteLine ( e ) ;
                throw ;
            }
        }
    }
}